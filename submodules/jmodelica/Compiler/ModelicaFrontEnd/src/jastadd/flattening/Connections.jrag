/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.Set;
import java.util.ArrayDeque;
import java.util.PriorityQueue;

import org.jmodelica.util.Enumerator;
import org.jmodelica.util.collections.GrowableSetIterable;

aspect Connections {

	/* Machinery to manage connection sets */

	public ConnectionSetManager FClass.connectionSetManager = new ConnectionSetManager();
	
	public ConnectionSetManager FClass.getConnectionSetManager() {
		return connectionSetManager;
	}

    public void FClass.genConnectionEquations(Flattener f) {
        beginStep("genConnectionEquations()");
        for (ConnectionSet set : connectionSetManager.getConnectionSetList()) 
            set.generateEquations(f);
        connectionSetManager.generateEqualityConstraints(f);
        connectionSetManager.disconnectFromInstanceTree();
        endStep("genConnectionEquations()");
    }

    public void ASTNode.enableStreamsRewrite() {
        for (ASTNode n : this)
            n.enableStreamsRewrite();
    }

    public void FStreamBuiltIn.enableStreamsRewrite() {
        super.enableStreamsRewrite();
        rewriteStreams = true;
        is$Final = false;
    }

    protected boolean FStreamBuiltIn.rewriteStreams = false;

    public class FClass {
        public class enableStreamsRewrite extends Transformation {
            // Depends on enableIfEquationElimination being done
            public void perform() {
                enableStreamsRewrite();
                change();
            }
        }
    }

    /**
     * Rewrite the inSteam operator to expanded form.
     */
    rewrite FInStream {
        when (rewriteStreams) to FExp expandInStreamExp();
    }

    protected FExp FInStream.expandInStreamExp() {
        // Always create expression from the connection set where the variable is an inside connector. 
        String name = getFExp().asCommonAccess().name();
        ConnectionSet cs = myFClass().getConnectionSetManager().getStreamConnectionSet(name, false);
        return cs.expandInStreamExp(name);
    }

    protected FExp FDerStream.expandInStreamExp() {
        // Note: this handles both enableStreamsRewrite and enableExpandedInStreamRewrite
        if (getFExp().needsLaterInStreamRewrite()) {
            return new FDerStream(getFExp().treeCopy());
        } else {
            return getFExp().diff(FExp.TIME);
        }
    }

    syn boolean FExp.needsLaterInStreamRewrite() = false;
    eq FExInStream.needsLaterInStreamRewrite()   = true;
    eq FDerStream.needsLaterInStreamRewrite()    = true;

    public class FClass {
        public class enableExpandedInStreamRewrite extends Transformation {
            // Depends on variabilityPropagationIfSet and the following aliasEliminationIfSet being done
            public void perform() {
                enableExpandedInStreamRewrite();
                change();
            }
        }
    }
    
    public void ASTNode.enableExpandedInStreamRewrite() {
        for (ASTNode n : this)
            n.enableExpandedInStreamRewrite();
    }
    
    public void FDerStream.enableExpandedInStreamRewrite() {
        super.enableExpandedInStreamRewrite();
        rewriteStreams = true;
        is$Final = false;
    }

    public void FExInStream.enableExpandedInStreamRewrite() {
        super.enableExpandedInStreamRewrite();
        
        // We don't need to add anything for < 2 contributors
        FExp stream = getDefault().treeCopy();
        int n = 0;
        for (InStreamPart cont : contributors()) {
            stream = cont.stream.treeCopy();
            n++;
            if (n > 1) {
                break;
            }
        }
        if (n < 2) {
            replaceMe(stream);
            return;
        }
        
        FExp eps   = getEps();
        FExp alpha = generateAlpha(eps, generateS());
        
        // Generate replacement expression
        ArrayList<FExp> nominatorTerms   = new ArrayList<FExp>();
        ArrayList<FExp> denominatorTerms = new ArrayList<FExp>();
        for (InStreamPart cont : contributors()) {
            stream = cont.stream.treeCopy();
            FExp flow = cont.flow.treeCopy();
            if (!cont.outside) {
                flow = new FNegExp(flow);
            }
            FExp posMax = positiveMax(eps, flow, alpha);
            nominatorTerms.add(new FMulExp(posMax.treeCopyNoTransform(), stream));
            denominatorTerms.add(posMax);
        }
        replaceMe(new FDivExp(
                FExp.createBalancedBinaryTree(new FAddExp(), nominatorTerms),
                FExp.createBalancedBinaryTree(new FAddExp(), denominatorTerms)));
    }

    /**
     * Generate and add variable with varType, add an equation for the variable with rhs <code>exp</code>.
     */
    private FExp FExInStream.addEquation(FlatVariableMap.GeneratedVarType varType, FExp exp) {
        String name = calcGeneratedVarName(varType);
        TypePrefixVariability v = variability().combine(Variability.FIXEDPARAMETER);
        myFClass().addFVariable(type().createTempFVariable(new FAccessString(name), variability()));
        myFClass().equationList(v).add(new FEquation(new FAccessExp(name), exp));
        return new FAccessExp(name);
    }
    
    /**
     * Get (no transform) equation list matching the variability <code>v</code>.
     */
    public List<FAbstractEquation> FClass.equationList(TypePrefixVariability v) {
        if (v.knownParameterOrLess()) {
            throw new UnsupportedOperationException();
        } else if (v.fixedParameterVariability()) {
            return getParameterEquationsNoTransform();
        } else if (v.initialParameterVariability()) {
            return getFInitialEquationsNoTransform();
        } else {
            return getFAbstractEquationsNoTransform();
        }
    }

    /** 
     * Add variable and equation for s_i, return reference to s_i
     */
    private FExp FExInStream.generateS() {
        ArrayList<FExp> terms = new ArrayList<FExp>();
        for (InStreamPart cont : contributors()) {
            FExp flow = cont.flow.treeCopy();
            if (!cont.outside) {
                flow = new FNegExp(flow);
            }
            terms.add(new FMaxExp(flow, new Opt<FExp>(new FIntegerLitExp(0))));
            
        }
        return addEquation(FlatVariableMap.GeneratedVarType.STREAM_S,
                FExp.createBalancedBinaryTree(new FAddExp(), terms));
    }

    /** 
     * Add variable and equation for alpha_i, return reference to alpha_i
     */
    private FExp FExInStream.generateAlpha(FExp eps, FExp s) {
        FExp sDivEps = new FDivExp(s.treeCopyNoTransform(), eps.treeCopyNoTransform());
        FExp alpha = new FSmoothExp(
                new FIntegerLitExp(1), 
                new FIfExp(
                        new FGtExp(
                                s.treeCopyNoTransform(),
                                eps.treeCopyNoTransform()),
                        new FIntegerLitExp(1),
                        new FIfExp(
                                new FGtExp(
                                        s.treeCopyNoTransform(),
                                        new FIntegerLitExp(0)),
                                new FMulExp(
                                        sDivEps.treeCopyNoTransform(), 
                                        new FMulExp(
                                                sDivEps.treeCopyNoTransform(),
                                                new FSubExp(
                                                        new FIntegerLitExp(3),
                                                        new FMulExp(
                                                                new FIntegerLitExp(2),
                                                                s.treeCopyNoTransform())))),
                                new FIntegerLitExp(0))));
        return addEquation(FlatVariableMap.GeneratedVarType.STREAM_ALPHA, alpha);
    }

    /** 
     * Add variable and equation for positiveMax_i, return reference to positiveMax_i
     */
    private FExp FExInStream.positiveMax(FExp eps, FExp flow, FExp alpha) {
        FExp exp = new FAddExp(
                new FMulExp(
                        alpha.treeCopyNoTransform(),
                        new FMaxExp(
                                flow,
                                new Opt<FExp>(new FIntegerLitExp(0)))),
                new FMulExp(
                        new FSubExp(
                                new FIntegerLitExp(1),
                                alpha.treeCopyNoTransform()),
                        eps.treeCopyNoTransform()));
        return addEquation(FlatVariableMap.GeneratedVarType.STREAM_POSMAX, exp);
    }


    syn int FExInStream.numVars() = getNumVar() / 3;

    syn FExp FExInStream.flowExp(int i) = getVar(i * 3);

    syn FExp FExInStream.streamExp(int i) = getVar(i * 3 + 1);

    syn FExp FExInStream.isOutsideExp(int i) = getVar(i * 3 + 2);

    syn boolean FExInStream.isOutside(int i) = isOutsideExp(i).ceval().booleanValue();

    public class FExInStream {
        /**
         * An iterable over all stream/flow pairs that contribute to this inStream().
         */
        public Iterable<InStreamPart> contributors() {
            return new ContributorIterable();
        }
        
        public class InStreamPart {
            public final FExp flow;
            public final FExp stream;
            public final boolean outside;

            public InStreamPart(int i) {
                flow = flowExp(i);
                stream = streamExp(i);
                outside = isOutside(i);
            }

            public boolean contributes() {
                if (outside) {
                    return flow.maxRealValue() > 0;
                } else {
                    return flow.minRealValue() < 0;
                }
            }
        }

        private class ContributorIterable implements Iterable<InStreamPart> {
            private int n = numVars();
            
            public Iterator<InStreamPart> iterator() {
                return new ContributorIterator();
            }

            private class ContributorIterator implements Iterator<InStreamPart> {
                private int i;
                private InStreamPart next;

                public ContributorIterator() {
                    i = -1;
                    step();
                }

                public boolean hasNext() {
                    return i < n;
                }

                public InStreamPart next() {
                    InStreamPart res = next;
                    step();
                    return res;
                }
                
                public void remove() {
                    throw new UnsupportedOperationException();
                }

                private void step() {
                    do {
                        i++;
                        next = (i < n) ? new InStreamPart(i) : null;
                    } while (i < n && !next.contributes());
                }
            }
        }
    }

    /**
     * Check if this expression is multiplied with the given variable.
     */
    inh boolean FExp.isMultipliedWith(FVariable v);
    eq BaseNode.getChild().isMultipliedWith(FVariable v)          = false;
    eq FDotMulExp.getRight().isMultipliedWith(FVariable v)        = getLeft().isMultiplicationOf(v) || isMultipliedWith(v);
    eq FDotMulExp.getLeft().isMultipliedWith(FVariable v)         = getRight().isMultiplicationOf(v) || isMultipliedWith(v);
    eq FSemiLinearExp.getPosSlope().isMultipliedWith(FVariable v) = getX().isMultiplicationOf(v) || isMultipliedWith(v);
    eq FSemiLinearExp.getNegSlope().isMultipliedWith(FVariable v) = getX().isMultiplicationOf(v) || isMultipliedWith(v);

    /**
     * Check if this expression is an access to v or a multiplication where one of the 
     * multiplicands is an access to v.
     */
    syn boolean FExp.isMultiplicationOf(FVariable v) = false;
    eq FAccessExp.isMultiplicationOf(FVariable v)    = v == myFV();
    eq FNegExp.isMultiplicationOf(FVariable v)       = getFExp().isMultiplicationOf(v);
    eq FDotMulExp.isMultiplicationOf(FVariable v)    = 
        getLeft().isMultiplicationOf(v) || getRight().isMultiplicationOf(v);

    rewrite FActualStream {
        when (rewriteStreams) to FExp {
            // Get the stream variable name prefix
            FAccess varName = getFExp().asFAccessExp().getFAccess();
            FAccess prefix = varName.copyPrefix();
            ArrayList<ConnectionSetEntry> cses = 
                myFClass().getConnectionSetManager().getFlowVariables(prefix.name());
            ConnectionSetEntry cse = null;
            if (cses.size() == 1) {
                cse = cses.get(0);
            } else if (cses.size() == 2) {
                cse = cses.get(0);
                // Check that this is an inside and an outside entry for the same name
                ConnectionSetEntry cse2 = cses.get(1);
                if (cse.isInside() == cse2.isInside() || !cse.name().equals(cse2.name()))
                    cse = null;
            }
            if (cse != null) {
                // Get the name of the single flow variable of the connector, then get the variables.
                FAccess flowVarName = cse.getFAccess();
                FRealVariable var = (FRealVariable) varName.myFV();
                FRealVariable flowVar = (FRealVariable) varName.lookupFV(cse.name());
                
                // Decide what parts are valid
                boolean constant = flowVar.isConstant();
                double min = constant ? flowVar.ceval().realValue() : flowVar.minAttribute();
                double max = constant ? min : flowVar.maxAttribute();
                boolean multFlow = isMultipliedWith(flowVar);
                boolean badMinMax = min > max;
                boolean thenValid = badMinMax || max > 0.0;
                boolean elseValid = badMinMax || min < 0.0 || (min == 0.0 && !(thenValid && multFlow));
                
                // Generate the expression
                FExp res = null, elseExp = null;
                FInStream thenExp = null;
                if (thenValid) {
                    res = thenExp = new FInStream(var.createAccessExp());
                    thenExp.rewriteStreams = true; // Enable further rewrite of the inStream operator.
                }
                if (elseValid) 
                    res = elseExp = var.createAccessExp();
                if (thenValid && elseValid) {
                    FExp guard = new FGtExp(flowVar.createAccessExp(), new FRealLitExp(0.0));
                    res = new FIfExp(guard, thenExp, elseExp);
                    if (multFlow)
                        res = new FSmoothExp(0, res);
                }
                return res;
            }
            // There should already have been an error message in this case, so we should never come here.
            throw new UnsupportedOperationException("Rewriting actualStream() for '" + varName.name() + 
                    "': found " + cses.size() + " matching flow variables");
        }
    }

	
	public abstract class ConnectionSet extends TreeSet<ConnectionSetEntry> {
		
		protected ConnectionSet(ConnectionSetEntry e) {
			add(e);
		}
		
		public static ConnectionSet create(ConnectionSetEntry e) {
			if (e.isFlow())
				return new FlowConnectionSet(e);
			else if (e.isStream())
				return new StreamConnectionSet(e);
			else 
				return new PotentialConnectionSet(e);
		}
		
		public void disconnectFromInstanceTree() {
			for (ConnectionSetEntry e : this)
				e.disconnectFromInstanceTree();
		}
		
		public int getNumInside() {
			int nInside = 0;
			for (ConnectionSetEntry cse : this) {
				if (cse.isInside()) {
					nInside++;
				}
			}
			return nInside;
		}
		
		public int getNumOutside() {
			int nOutside = 0;
			for (ConnectionSetEntry cse : this) {
				if (cse.isOutside()) {
					nOutside++;
				}
			}
			return nOutside;
		}

		public ConnectionSetEntry getConnectionSetEntry(String name, boolean outside) {
			for (ConnectionSetEntry cse : this) {
				if (cse.equals(name, outside)) {
					return cse;
				}
			}
			return null;
		}
		
		/**
		 * Check if a rewrite expression can be generated for an inStream() on a variable in this set.
		 * 
		 * Default implementation returns false, since inStream() only applies to stream connecton sets.
		 */
		public boolean canCreateInStreamExp() {
			return false;
		}
		
		/**
		 * Create rewrite expression for an inStream() on a variable in this set.
		 * 
		 * Only valid for stream connecton sets.
		 * 
		 * @param name  the name of the variable to generate name for
		 */
		public FExp expandInStreamExp(String name) {
			throw new UnsupportedOperationException();
		}
		
		/**
		 * Generate equations for this set.
		 * 
		 * @param eqns  equation list to add equations to
		 */
		public abstract void generateEquations(Flattener f);
		
		/**
		 * Return all ConnectionSetEntrys corresponding to flow variables based
		 * on a name prefix. This method is useful when generating expressions
		 * for actualStream operators when the name of the flow variable in a
		 * stream connector is needed.
		 */
		public ArrayList<ConnectionSetEntry> getFlowVariables(String prefix) {
			return new ArrayList<ConnectionSetEntry>(0);
		}
		
		public int numStreamVariables() {
			int n_stream_vars = 0;
			for (ConnectionSetEntry e : this) {
				if (e.isStream()) {
					n_stream_vars++;
				}
			}
			return n_stream_vars;
		}
		
		public String toString() {
			StringBuffer str = new StringBuffer();
			
			str.append("Connection set (");
			str.append(typeString());
			str.append("): {");
			String set_str = super.toString();
			str.append(set_str.substring(1, set_str.length() - 1));
			str.append("}\n");
			return str.toString();
		}
		
		protected abstract String typeString();
		
	}
	
	public class FlowConnectionSet extends ConnectionSet {
		
		public FlowConnectionSet(ConnectionSetEntry e) {
			super(e);
		}
		
		public String typeString() {
			return "flow";
		}
		
		public ArrayList<ConnectionSetEntry> getFlowVariables(String prefix) {
			ArrayList<ConnectionSetEntry> cses = new ArrayList<ConnectionSetEntry>();
			for (ConnectionSetEntry cse : this) 
				if (cse.prefix().equals(prefix)) 
					cses.add(cse);
			return cses;
		}

        public void generateEquations(Flattener f) {
            ConnectionSetEntry fst = first();
            if (size() == 1 && fst.isInside() && fst.getVar().isTopLevelInputOutput()) {
                return;
            }
            FExp e = null;
            for (ConnectionSetEntry cse : this) 
                e = cse.buildFlow(e);
            FExp zero = fst.createZeroExp();
            f.addNormalEquation(new FEquation(e, zero));
        }

	}

    public class StreamConnectionSet extends ConnectionSet {

        private double nominal = Double.MAX_VALUE;

        public StreamConnectionSet(ConnectionSetEntry e) {
            super(e);
        }

        public String typeString() {
            return "stream";
        }

        public void generateEquations(Flattener f) {
            for (ConnectionSetEntry e : this) {
                nominal = Math.min(e.flowNominal(), nominal);
            }
            for (ConnectionSetEntry e : this) {
                if (e.isOutside()) {
                    FExp left = e.createFAccessExp();
                    FExp right = expandInStreamExp(e, null, e.createZeroExp());
                    f.addNormalEquation(new FEquation(left, right));
                }
            }
        }

        /**
         * Create rewrite expression for an inStream() on a variable in this set.
         * 
         * @param name  the name of the variable to generate name for
         */
        public FExp expandInStreamExp(String name) {
            ConnectionSetEntry e = getConnectionSetEntry(name, false);
            FExp exp = expandInStreamExp(e, name, new FAccessExp(name));
            exp.enableStreamsRewrite();
            return exp;
        }

        /**
         * Create an expression for the inStream() of the given entry.
         * 
         * Used for inStream() for inside entries and for additional equations for outside entries.
         * 
         * @param cse   the entry to generate the expression for
         * @param name  the name of the scalar var to generate the stream access for, 
         *              of null for the entire array (in scalar case they are equivalent)
         * @param def   expression to use when there are no contributing streams
         */
        private FExp expandInStreamExp(ConnectionSetEntry cse, String name, FExp def) {
            FExp stream = def;
            List<FExp> vars = new List<FExp>();
            for (ConnectionSetEntry e : this) {
                if (cse != e) {
                    stream = (name == null) ? e.createFAccessExp() : e.createCommonAccessExp(name, cse);
                    if (e.isOutside()) 
                        stream = new FInStream(stream);
                    vars.add(e.createFlowCommonAccessExp());
                    vars.add(stream);
                    vars.add(FBooleanLitExp.create(e.isOutside()));
                }
            }
            
            if (vars.getNumChildNoTransform() < 6) {
                return stream;
            } else {
                return new FExInStream(def, new FMulExp(new FInStreamEpsExp(), new FRealLitExp(nominal)), vars);
            }
        }
    }

    /**
     * Find the flow variable corresponding to this stream variable.
     * 
     * Only valid for stream variables.
     */
    inh InstComponentDecl InstComponentDecl.myFlowVar();
    eq InstComponentDecl.getChild().myFlowVar() = isConnector() ? findFlowVar() : null;
    eq InstClassDecl.getChild().myFlowVar()     = isConnector() ? findFlowVar() : null;
    eq InstRoot.getChild().myFlowVar()          = null;
    eq Root.getChild().myFlowVar()              = null;

    /**
     * Find the first flow variable in this node, if any.
     */
    syn InstComponentDecl InstNode.findFlowVar() {
        for (InstComponentDecl icd : allInstComponentDecls())
            if (icd.isFlow())
                return icd;
        return null;
    }

    public class PotentialConnectionSet extends ConnectionSet {
        
        public PotentialConnectionSet(ConnectionSetEntry e) {
            super(e);
        }

        public String typeString() {
            return "potential";
        }

        public void generateEquations(Flattener f) {
            if (size() == 1) {
                // Cell that is not connected to in array in expandable connector
                f.addNormalEquation(first().createZeroEquation());
            } else {
                FExp e1 = null;
                for (ConnectionSetEntry cse : this) {
                    FExp e2 = cse.createFAccessExp();
                    if (e1 != null) {
                        f.addNormalEquation(new FEquation(e1, e2));
                    }
                    e1 = e2;
                }
            }
        }
        
    }


	public class ConnectionSetManager {
	
		private ArrayList<ConnectionSet> list = new ArrayList<ConnectionSet>();
		private ArrayList<EqualityConstraintConnection> equalityConstraints = new ArrayList<EqualityConstraintConnection>();
		private Map<ConnectionSetEntry, ConnectionSet> cseMap = new HashMap<ConnectionSetEntry, ConnectionSet>();
		private Map<String, CSENameMapEntry> cseStreamMap = new HashMap<String, CSENameMapEntry>();
		private OverconstrainedConnectionGraph graph = null;
		private ExpandableConnectorSets expandable = null;
		
        private static class CSENameMapEntry {
            private ConnectionSetEntry outsideCSE = null;
            private ConnectionSet outside = null;
            private ConnectionSetEntry insideCSE = null;
            private ConnectionSet inside = null;
        }

        private void updateCSEMapEntry(ConnectionSetEntry cse, ConnectionSet newValue) {
            cseMap.put(cse, newValue);
            if (cse.isStream()) {
                for (String name : cse.names()) {
                    CSENameMapEntry entry = cseStreamMap.get(name);
                    if (entry == null) {
                        entry = new CSENameMapEntry();
                        cseStreamMap.put(name, entry);
                    }
                    if (cse.isOutside()) {
                        entry.outsideCSE = cse;
                        entry.outside = newValue;
                    } else {
                        entry.insideCSE = cse;
                        entry.inside = newValue;
                    }
                }
            }
        }
		
		public ArrayList<ConnectionSet> getConnectionSetList() {
			return list;
		}
		
		public OverconstrainedConnectionGraph getGraph() {
			if (graph == null) 
				graph = new OverconstrainedConnectionGraph();
			return graph;
		}
        
       public ExpandableConnectorSets getExpandable() {
           if (expandable == null) 
               expandable = new ExpandableConnectorSets();
           return expandable;
       }
       
      public boolean isExpandableConnectorsDone() {
          return expandable != null && expandable.isExpansionDone();
      }

        public void buildOverconstrainedConnectionTrees() {
            if (graph != null) 
                graph.buildTrees(this);
        }
        
        public void elaborateExpandableConnectors() {
            if (expandable != null) {
                expandable.elaborate(this);
                expandable = null;
            }
        }

        public void addFlowVar(InstComponentDecl var, boolean outside, FAccess name) {
            addVar(ConnectionSetEntry.create(var, outside, name));
        }

        public void addExpandableArrayMember(InstComponentDecl var, FAccess name) {
            // If var is present as inner, don't add it as outer
            if (getConnectionSet(ConnectionSetEntry.create(var, false, name)) == null)
                addVar(ConnectionSetEntry.create(var, true, name));
        }

		/**
		 * Add vars to connection sets.
		 * 
		 * Filters out parameters and constants.
		 */
		public void addVars(ConnectionSetEntry cse1, ConnectionSetEntry cse2) {

//			log.debug("ConnectionSetManager.addVars");
		
//		    System.out.println(namePrefix1.name()+" . "+var1.name() + " outside: " + outside1);
//		    System.out.println(namePrefix2.name()+" . "+var2.name() + " outside: " + outside2);
		
			// Don't add parameters or constants to connection set
			// TODO: Add them, but generate asserts instead of equations
			if (cse1.getVar().variability().parameterOrLess() || cse2.getVar().variability().parameterOrLess()) 
				return;

			ConnectionSet setA = getConnectionSet(cse1);
			ConnectionSet setB = getConnectionSet(cse2);
			
			if (setA != null && setB != null) {
				if (setA != setB)
					merge(setA, setB);
			} else if (setA != null && setB == null) {
				add(setA, cse2);
			} else if (setA == null && setB != null) {
				add(setB, cse1);
			} else if (setA == null && setB == null) {
				join(cse1, cse2);
			}
		}
		
		public void addEqualityConstraint(ConnectionSetEntry cse1, ConnectionSetEntry cse2, FAccess prefix) {
			equalityConstraints.add(new EqualityConstraintConnection(cse1, cse2, prefix));
		}
        
        private void addVar(ConnectionSetEntry entry) {
            if (getConnectionSet(entry) == null) {
                ConnectionSet set = ConnectionSet.create(entry);
                list.add(set);
                updateCSEMapEntry(entry, set);
            }
        }
		
		private void join(ConnectionSetEntry entryA, ConnectionSetEntry entryB) {
			ConnectionSet set = ConnectionSet.create(entryA);
			set.add(entryB);
			list.add(set);
			updateCSEMapEntry(entryA, set);
			updateCSEMapEntry(entryB, set);
		}
		
		private void add(ConnectionSet set, ConnectionSetEntry entry) {
			set.add(entry);
			updateCSEMapEntry(entry, set);
		}
		
		private void merge(ConnectionSet setA, ConnectionSet setB) {
			if (setA.size() < setB.size()) {
				ConnectionSet tmp = setA;
				setA = setB;
				setB = tmp;
			}
			for (ConnectionSetEntry entry : setB)
			    updateCSEMapEntry(entry, setA);
			setA.addAll(setB);
			list.remove(setB);
		}
		
		public ConnectionSet getConnectionSet(ConnectionSetEntry cse) {
			return cseMap.get(cse);
		}

		public ConnectionSet getStreamConnectionSet(String name, boolean outside) {
            CSENameMapEntry entry = cseStreamMap.get(name);
            if (entry == null)
                return null;
            if (outside)
                return entry.outside;
            else
                return entry.inside;
		}

		public ArrayList<ConnectionSetEntry> getFlowVariables(String prefix) {
			ArrayList<ConnectionSetEntry> cses = new ArrayList<ConnectionSetEntry>();
			for (ConnectionSet set : list) {
				cses.addAll(set.getFlowVariables(prefix));		
			}
			return cses;
		}
		
		public void disconnectFromInstanceTree() {
			for (ConnectionSet set : list)
				set.disconnectFromInstanceTree();
            if (graph != null) 
                graph.disconnectFromInstanceTree();
			equalityConstraints = null;
		}
		
		public void generateEqualityConstraints(Flattener f) {
			for (EqualityConstraintConnection ecc : equalityConstraints)
				ecc.generate(f);
		}
		
		public String printConnectionSets() {
		
			StringBuffer str = new StringBuffer();
			
			str.append("Connection sets: " + list.size() + " sets\n");
			
			// Print connection sets 
			for(ConnectionSet set : list) {
				str.append(set);
			}

			return str.toString();
		}
	}


    public class ConnectionSetEntry implements Comparable<ConnectionSetEntry> {

        private InstComponentDecl cd;
        private boolean outside;
        private FAccess access;
        private String prefix;
        private String str;
        private String[] scalarNames;

        public static ConnectionSetEntry create(InstComponentDecl cd, boolean outside, FAccess access) {
            if (cd.isFlow()) 
                return new FlowConnectionSetEntry(cd, outside, access);
            if (cd.isStream()) 
                return new StreamConnectionSetEntry(cd, outside, access);
            return new ConnectionSetEntry(cd, outside, access);
        }

        private ConnectionSetEntry(InstComponentDecl cd, boolean outside, FAccess access) {
            //log.debug("Created ConnectionSetEntry: " + cd.name());
            this.cd = cd;
            this.outside = outside;
            this.access = access;
            prefix = null;
        }

        public void disconnectFromInstanceTree() {
            cd = null;
        }

        public boolean isOutside() {
            return outside;
        }

        public boolean isInside() {
            return !outside;
        }

        public InstComponentDecl getVar() {
            return cd;
        }

        public boolean isFlow() {
            return false;
        }

        public boolean isStream() {
            return false;
        }

        public String name() {
           return access.name();
        }
        
        public String[] names() {
            if (scalarNames != null)
                return scalarNames;
            else
                return new String[] {name()};
        }

        public String prefix() {
            if (prefix == null) 
                prefix = access.copyPrefix().name();
            return prefix;
        }

        public boolean equals(String name, boolean outside) {
            if (outside != this.outside)
                return false;
            if (scalarNames != null) {
                for (String scalarName : scalarNames)
                    if (name.equals(scalarName))
                        return true;
                return false;
            } else {
                return name.equals(name());
            }
        }

        public String toString() {
            if (str == null)
                str = access + (outside ? " (o)" : " (i)");
            return str;
        }

        public FAccess getFAccess() {
            return access;
        }

        public FAccessExp createFAccessExp() {
            return new FAccessExp(access.treeCopy());
        }

        /**
         * Create an FAccessExp that is an access to a variable in this entry, that is connected to 
         * the variable named <code>name</code> in <code>other</code>.
         */
        public FAccessExp createCommonAccessExp(String name, ConnectionSetEntry other) {
            if (other == this)
                return new FAccessExp(name); 
            if (scalarNames == null || other.scalarNames == null)
                return createFAccessExp();
            int i;
            for (i = 0; i < other.scalarNames.length && !other.scalarNames[i].equals(name); i++);
            return (i < scalarNames.length) ? new FAccessExp(scalarNames[i]) : createFAccessExp();
        }

        /**
         * Create a zero expression suitable for this entry.
         */
        public FExp createZeroExp() {
            FType t = cd.type();
            if (access.hasFArraySubscripts() && access.getFArraySubscripts().accessNdims() == 0) {
                t = t.scalarType();
            }
            return t.flattenZeroLiteral();
        }

        /**
         * Create an equation setting the variable of this entry to zero.
         */
        public FAbstractEquation createZeroEquation() {
            return new FEquation(createFAccessExp(), createZeroExp());
        }

        /**
         * Create an access to the var of this entry and add or subtract it to/from e.
         * 
         * Used to build up flow equations.
         */
        public FExp buildFlow(FExp e) {
            return createFAccessExp().appendSum(e, outside, cd.type());
        }

        public int hashCode() {
            return toString().hashCode();
        }

        /**
         * Create a new connection set entry referring to a specific cell of the variable this refers to.
         * 
         * Assumes that the variable is an array and that <code>i</code> is suitable.
         */
        public ConnectionSetEntry specifyCell(Index i) {
            InstComponentDecl cell = cd.findCell(i, 0);
            return ConnectionSetEntry.create(cell, outside, cell.getFAccess(i));
        }

        public boolean equals(Object o) {
            return o instanceof ConnectionSetEntry && toString().equals(o.toString());
        }
    
        public int compareTo(ConnectionSetEntry cse) {
            return toString().compareTo(cse.toString());
        }

        /**
         * Create an access expression to the associated flow variable.
         * 
         * Only valid for stream connection entries.
         */
        public FExp createFlowCommonAccessExp() {
            throw new UnsupportedOperationException("Only supported for stream connection sets");
        }

        /**
         * Get the epsilon to use when calculating flows, based on the associated flow variable's nominal value.
         * 
         * Only valid for stream connection entries.
         */
         public double flowNominal() {
             throw new UnsupportedOperationException("Only supported for stream connection sets");
        }

         /**
          * Check if this entry should contribute when calculating streams.
          * 
          * Only valid for stream connection entries.
          */
          public boolean contributesToStream() {
              throw new UnsupportedOperationException("Only supported for stream connection sets");
        }


        private static class FlowConnectionSetEntry extends ConnectionSetEntry {

            public FlowConnectionSetEntry(InstComponentDecl cd, boolean outside, FAccess access) {
                super(cd, outside, access);
            }

            public boolean isFlow() {
                return true;
            }

        }

        private static class StreamConnectionSetEntry extends ConnectionSetEntry {

            private FExp flowExp;
            private double nominal = 1;
            private boolean contribute = true;

            public StreamConnectionSetEntry(InstComponentDecl cd, boolean outside, FAccess access) {
                super(cd, outside, access);
                InstComponentDecl flow = cd.myFlowVar();
                flowExp = new FAccessExp(flow.getFAccess().treeCopy());
                try {
                    CValue cval = flow.nominalAttributeCValue();
                    if (cval.hasRealValue()) {
                        nominal = Math.abs(cval.realValue());
                    }
                } catch (ConstantEvaluationException e) {}
                try {
                    CValue cval = isOutside() ? flow.maxAttributeCValue() : flow.minAttributeCValue();
                    if (cval.hasRealValue()) {
                        double val = cval.realValue();
                        contribute = isOutside() ? (val > 0) : (val < 0);
                    }
                } catch (ConstantEvaluationException e) {}
            }

            public boolean isStream() {
                return true;
            }

            public FExp createFlowCommonAccessExp() {
                return flowExp.fullCopy();
            }

            public double flowNominal() {
                return nominal;
            }

            public boolean contributesToStream() {
                return contribute;
            }

        }

    }


    /**
     * Connect the variables referenced in a connect or branch statement in the connection set manager.
     * 
     * @param right   the other access
     * @param prefix  the prefix to use when flattening names
     * @param csm     the connection set manager to add variables to
     * @param source  the originating connect or branch statement
     */
    public void InstAccess.connectTo(InstAccess right, FAccess prefix, ConnectionSetManager csm, ConnectionEdge source) {
        
        boolean leftOutside  = isOutsideConnector();
        boolean rightOutside = right.isOutsideConnector();
        InstComponentDecl leftComp  = lookupEvaluatingIndices();
        InstComponentDecl rightComp = right.lookupEvaluatingIndices();
        
        boolean handleExpandable = !csm.isExpandableConnectorsDone();
        if (handleExpandable && (isExpandableConnectorPart() || right.isExpandableConnectorPart())) {
            if (isExpandableConnectorPart())
                csm.getExpandable().addIntroducingConnection(this, right, prefix, source);
            if (right.isExpandableConnectorPart())
                csm.getExpandable().addIntroducingConnection(right, this, prefix, source);
        } else if (handleExpandable && leftComp.isExpandableConnector()) {
            csm.getExpandable().addSpanningConnection(leftComp, rightComp, prefix, source);
        } else if (isArray() && !leftComp.isOverconstrainedConnection(rightComp)) {
            Indices leftInd = indices();
            Indices rightInd = right.indices();
            Iterator<Index> leftIter = leftInd.iterator();
            Iterator<Index> rightIter = rightInd.iterator();
            while (leftIter.hasNext() && rightIter.hasNext()) {
                Index leftI = leftInd.translate(leftIter.next());
                Index rightI = rightInd.translate(rightIter.next());
                InstComponentDecl leftCompCell = leftComp.findCell(leftI, leftI.ndims() - leftComp.ndims());
                InstComponentDecl rightCompCell = rightComp.findCell(rightI, rightI.ndims() - rightComp.ndims());
                FAccess leftCellName  = leftCompCell.getFAccess(leftI);
                FAccess rightCellName = rightCompCell.getFAccess(rightI);
                ConnectionSetEntry leftEntry = ConnectionSetEntry.create(leftCompCell, leftOutside, leftCellName);
                ConnectionSetEntry rightEntry = ConnectionSetEntry.create(rightCompCell, rightOutside, rightCellName);
                leftCompCell.connectTo(leftEntry, rightEntry, prefix, csm, source, true);
            }
        } else {
            FAccess leftName  = leftComp.getFAccess(index());
            FAccess rightName = rightComp.getFAccess(right.index());
            ConnectionSetEntry leftEntry = ConnectionSetEntry.create(leftComp, leftOutside, leftName);
            ConnectionSetEntry rightEntry = ConnectionSetEntry.create(rightComp, rightOutside, rightName);
            leftComp.connectTo(leftEntry, rightEntry, prefix, csm, source, true);
        }
    }

    /**
     * Helper method for constructing FAccesss for connection sets
     */
    public FAccess InstComponentDecl.getFAccess(Index i) {
        FAccess res = getFAccess();
        if (isArray()) {
            if (i.ndims() > 0) {
                res = res.copyAndAddFas(i.subIndex(i.ndims() - ndims()).createFArraySubscripts());
            } else {
                res = res.copyAndAddFas(expandedSubscripts());
            }
        }
        return res;
    }
    
    syn Index InstAccess.index() = hasFArraySubscripts() ?
            getFArraySubscripts().createIndex() :
            Index.NULL;

    /**
     * Connect the variables referenced in a connect or branch statement in the connection set manager.
     * 
     * @param left        describes current part of the left access
     * @param right       describes current part of the right access
     * @param prefix      the prefix to use when flattening names
     * @param csm         the connection set manager to add variables to
     * @param source      the originating connect or branch statement
     * @param buildGraph  if true, pass instances of overconstrained types to overconstrained connection graph
     */
    public void InstComponentDecl.connectTo(ConnectionSetEntry left, ConnectionSetEntry right, 
            FAccess prefix, ConnectionSetManager csm, ConnectionEdge source, boolean buildGraph) {
        if (!isDisabled() && !right.getVar().isDisabled()) {
            if (buildGraph && isOverconstrainedConnection(right.getVar())) {
                csm.getGraph().addConnection(left, right, prefix, source);
            } else if (isArray()) {
                for (Index i : indices()) {
                    ConnectionSetEntry leftEntry = left.specifyCell(i);
                    ConnectionSetEntry rightEntry = right.specifyCell(i);
                    leftEntry.getVar().connectTo(leftEntry, rightEntry, prefix, csm, source, buildGraph);
                }
            } else if (isOperatorRecord()) {
                connectToAsPrimitive(left, right, prefix, csm, source, buildGraph);
            } else {
                SortedSet<InstComponentDecl> rightChildren = right.getVar().containedInstComponents();
                for (InstComponentDecl leftComp : containedInstComponents()) {
                    SortedSet<InstComponentDecl> rightTail = rightChildren.tailSet(leftComp);
                    if (rightTail.size() > 0) {
                        InstComponentDecl rightComp = rightTail.first();
                        FAccess leftName  = leftComp.getFAccess(Index.NULL);
                        FAccess rightName = rightComp.getFAccess(Index.NULL);
                        ConnectionSetEntry leftEntry = ConnectionSetEntry.create(leftComp, left.isOutside(), leftName);
                        ConnectionSetEntry rightEntry = ConnectionSetEntry.create(rightComp, right.isOutside(), rightName);
                        leftComp.connectTo(leftEntry, rightEntry, prefix, csm, source, buildGraph);
                    }
                }
            }
            csm.countCardinality(left.getFAccess().scalarName());
            csm.countCardinality(right.getFAccess().scalarName());
        }
    }

    public void InstPrimitive.connectTo(ConnectionSetEntry left, ConnectionSetEntry right, 
            FAccess prefix, ConnectionSetManager csm, ConnectionEdge source, boolean buildGraph) {
        if (!isDisabled() && !right.getVar().isDisabled())
            connectToAsPrimitive(left, right, prefix, csm, source, buildGraph);
    }

    public void InstComponentDecl.connectToAsPrimitive(ConnectionSetEntry left, ConnectionSetEntry right, 
            FAccess prefix, ConnectionSetManager csm, ConnectionEdge source, boolean buildGraph) {
        if (left.equals(right)) {
            source.warning("Ignored connection from connector to itself");
        } else {
            if (buildGraph && isOverconstrainedConnection(right.getVar())) {
                csm.getGraph().addConnection(left, right, prefix, source);
            } else {
                // In the special case of members of expandable connectors, we need each cell separately.
                if (isArray() && (isExpandableConnectorMember() || right.getVar().isExpandableConnectorMember()) && 
                        !left.getFAccess().hasScalarSubscripts()) 
                    for (Index i : indices())
                        csm.addVars(left.specifyCell(i), right.specifyCell(i));
                else
                    csm.addVars(left, right);
            }
            csm.countCardinality(left.getFAccess().scalarName());
            csm.countCardinality(right.getFAccess().scalarName());
        }
    }

    syn boolean FAccess.hasScalarSubscripts() {
        FArraySubscripts fas = getFArraySubscripts();
        if (fas == null)
            return false;
        for (Subscript s : fas.subscripts())
            if (s.ndims() > 0)
                return false;
        return true;
    }

    syn boolean InstComponentDecl.isOverconstrainedConnection(InstComponentDecl right) =
            isOverconstrainedType() && right.isOverconstrainedType();

    /**
     * Retrieve the specific cell for a given index from an array component.
     * 
     * What dimension of i that refers to the children of this component is given by j.
     */
    syn InstComponentDecl InstComponentDecl.findCell(Index i, int j) =
         ((j > 0) ? findCellUp(i, j, this) : this).findCellDown(i, j);

    inh InstComponentDecl InstComponentDecl.findCellUp(Index i, int j, InstComponentDecl src);
    eq InstComponentDecl.getChild().findCellUp(Index i, int j, InstComponentDecl src) {
        if (j > 0) {
            if (isArray()) {
                return findCellUp(i, j - 1, this).getInstComponentDecl(i.get(j - 1) - 1);
            } else {
                return findCellUp(i, j, this).memberInstComponent(src.name()).target();
            }
        }
        return src;
    }
    eq InstClassDecl.getChild().findCellUp(Index i, int j, InstComponentDecl src) = src;
    eq Root.getChild().findCellUp(Index i, int j, InstComponentDecl src) {
        throw new UnsupportedOperationException();
    }

    syn InstComponentDecl InstComponentDecl.findCellDown(Index i, int j) = 
        (j < i.ndims()) ? getInstComponentDecl(i.get(j) - 1).findCellDown(i, j + 1) : this;
    eq InstPrimitive.findCellDown(Index i, int j)                        = this;

	syn boolean InstAccess.isOutsideConnector() = getFirstInstAccess().myInstComponentDecl().isConnector();
	
	
	/**
	 * Traverse tree and build connection sets and overconstranined connection graph from relevant constructs.
	 * 
	 * @param prefix   the prefix to use when flattening names
	 * @param csm      the connection set manager to add variables to
	 * @param connect  if false, then we are in a dead branch, and shouldn't change sets or graph
	 */
	public void ASTNode.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		for (ASTNode n : this) 
			n.buildConnectionSets(prefix, csm, connect);
	}
	
	public void InstNode.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		prefix = getFAccess();
		for (FAbstractEquation ae : getFAbstractEquations()) 
		   ae.buildConnectionSets(prefix, csm, connect);
		getInstComponentDeclList().buildConnectionSets(prefix, csm, connect);
		getInstExtendsList().buildConnectionSets(prefix, csm, connect);
	}

    public void InstClassDecl.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        super.buildConnectionSets(prefix, csm, connect);
        getInstGeneratedInners().buildConnectionSets(prefix, csm, connect);
    }

	public void InstComponentDecl.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		if (useInFlattening()) 
			super.buildConnectionSets(prefix, csm, connect);
	}

    public void InstAssignable.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        if (useInFlattening() && hasBindingFExp())
            getBindingFExp().buildConnectionSets(prefix, csm, connect);
        if (isOperatorRecord())
            buildConnectionSetsAsPrimitive(prefix, csm, connect);
        else
            super.buildConnectionSets(prefix, csm, connect);
    }

    public void InstPrimitive.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        buildConnectionSetsAsPrimitive(prefix, csm, connect);
        super.buildConnectionSets(prefix, csm, connect);
    }

    public void InstComponentDecl.buildConnectionSetsAsPrimitive(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        if (useInFlattening() && (isFlow() || isStream())) {
            FAccess access = getFAccess(Index.NULL);
            csm.addFlowVar(this, false, access);
            if (inExpandableConnector()) {
                csm.addFlowVar(this, true, access);
            }
        }
    }

    public void FIfEquation.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        boolean all = true;
        boolean test = false;
        try {
            CValue cval = getTest().ceval();
            if (cval.hasBooleanValue()) {
                test = cval.booleanValue();
                all = false;
            }
        } catch (ConstantEvaluationException e) {
        }
        getTest().buildConnectionSets(prefix, csm, connect);
        for (FAbstractEquation equ : getFAbstractEquations())
            equ.buildConnectionSets(prefix, csm, (all || test) && connect);
        if (hasElse())
            getElse().buildConnectionSets(prefix, csm, (all || !test) && connect);
    }

	public void InstForClauseE.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		Indices indices = Indices.create(getInstForIndexs());
		for (Index i : indices) {
			int j = 0;
			int[] ii = indices.translate(i).index();
			for (InstForIndex fi : getInstForIndexs()) {
				fi.getInstPrimitive().setLocalCachedEvaluationValue(new CValueInteger(ii[j]));
				j++;
			}
			for (FAbstractEquation equ : getFAbstractEquations())
			    equ.buildConnectionSets(prefix, csm, connect);
			getFAbstractEquations().flushAllRecursive();
		}
		for (InstForIndex fi : getInstForIndexs()) {
			fi.getInstPrimitive().setLocalCachedEvaluationValue(null);
			fi.buildConnectionSets(prefix, csm, connect);
		}
	}

    public void FConnectClause.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        if (!isDisabled() && connect) {
            InstAccess left  = getConnector1();
            InstAccess right = getConnector2();
            left.connectTo(right, prefix, csm, this);
        }
    }

    syn boolean FConnectClause.isDisabled() = getConnector1().isDisabled() || getConnector2().isDisabled();

}

aspect OverconstrainedConnections {
	
	public void FConnBranch.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		if (connect) {
            InstAccess left  = getA().asInstAccess();
            InstAccess right = getB().asInstAccess();
			left.connectTo(right, prefix, csm, this);
		}
	}
	
	public void FConnRoot.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		if (connect)
			csm.getGraph().addRoot(variableA());
	}
	
	public void FConnPotentialRoot.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		if (connect) {
			int prio = hasPriority() ? getPriority().ceval().intValue() : 0;
			csm.getGraph().addPotentialRoot(variableA(), prio);
		}
	}
	
	public void FConnBoolOp.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
		connectionGraph = csm.getGraph();
	}
	
	/**
	 * Get the variable referenced by child A.
	 * 
     * Assumes A is an InstAccessExp.
	 */
	syn InstComponentDecl FConnectionsOp.variableA() = 
            getA().asInstAccess().myInstComponentDecl();
	
	
	/**
	 * Represents a broken branch in the overconstrained connection graph.
	 * 
	 * Generates a call to the relevant equalityConstraint() function.
	 */
	public class EqualityConstraintConnection {
		
		private ConnectionSetEntry cse1;
		private ConnectionSetEntry cse2;
		private FAccess prefix;
		
		public EqualityConstraintConnection(ConnectionSetEntry cse1, ConnectionSetEntry cse2, FAccess prefix) {
			this.cse1 = cse1;
			this.cse2 = cse2;
			this.prefix = prefix;
		}
		
		/**
		 * Generate the equalityConstraint() call.
		 */
		public void generate(Flattener f) {
			InstClassDecl func = cse1.getVar().equalityConstraint();
			func.flattenFunction(f);
			Size s = func.myOutputs().get(0).size();
			FFunctionCall right = new FFunctionCall();
			right.setName(new FAccessString(func.qualifiedName()));
            right.addArg(cse1.createFAccessExp());
            right.addArg(cse2.createFAccessExp());
            right.setFType(func.functionType().flatten(Flattener.expressionFlattener(), null, true));
			FAbstractEquation eqn;
			if (!s.isUnknown() && s.numElements() == 0) 
				eqn = new FFunctionCallEquation(new List<FFunctionCallLeft>(), right);
			else
				eqn = new FEquation(s.createZeroFExp(), right);
			f.addNormalEquation(eqn);
		}
		
	}
	
	/**
	 * Check if an assignable is of an overconstrained connection type.
	 */
	syn boolean InstComponentDecl.isOverconstrainedType() = equalityConstraint() != null;
	
	/**
	 * Name of equality constraint function.
	 */
	public static final String InstAssignable.EQUALITY_CONSTRAINT_NAME = "equalityConstraint";

    /**
     * Get the equality constraint function for this type, if any.
     */
    syn InstClassDecl InstComponentDecl.equalityConstraint()  = null;
    syn lazy InstClassDecl InstAssignable.equalityConstraint() {
        InstLookupResult<InstClassDecl> res = memberInstClass(EQUALITY_CONSTRAINT_NAME);
        if (!res.successful())
            res = myInstClass().memberInstClass(EQUALITY_CONSTRAINT_NAME);
        if (res.successful()) {
            InstClassDecl icd = res.target().actualInstClass();
            if (icd.isEqualityConstraint(type()))
                return icd;
        }
        return null;
    }

	/**
	 * Check if this is an equality constraint function for the given type.
	 */
	syn boolean InstClassDecl.isEqualityConstraint(FType type) {
		ArrayList<InstComponentDecl> inputs = myInputs();
		ArrayList<InstComponentDecl> outputs = myOutputs();
		return isFunction() && 
				inputs.size() == 2 && 
				inputs.get(0).type().typeCompatible(type, true) && 
				inputs.get(1).type().typeCompatible(type, true) && 
				outputs.size() == 1 && 
				outputs.get(0).ndims() == 1 && 
				outputs.get(0).type().isReal();
	}
	
	/**
	 * The source node for an edge in the overconstrained connection graph.
	 */
	public interface ConnectionEdge {
		
		/**
		 * Does this node represent a breakable branch in the overconstrained connection graph?
		 */
		public boolean isBreakable();
        
        /**
         * Report a warning.
         */
        public void warning(String msg);
        
        /**
         * Report an error.
         */
        public void error(String msg);
		
	}
	
	FConnectClause implements ConnectionEdge;
	FConnBranch implements ConnectionEdge;
	
	syn boolean FConnectClause.isBreakable() = true;
	syn boolean FConnBranch.isBreakable()    = false;
	
	/**
	 * Describes a system of overconstrained connenctions.
	 * 
	 * Will break loops in the graph to form spanning trees.
	 */
	public class OverconstrainedConnectionGraph {
		
		/**
		 * The calculated values for operators that depend on the graph for a specific component.
		 */
		public static class OpsResult {
			
			/** The result for the Connections.isRoot() operator. */
			public final boolean isRoot;
			/** The result for the Connections.rooted() operator. */
			public final boolean rooted;
			
			public OpsResult(boolean isRoot, boolean rooted) {
				this.isRoot = isRoot;
				this.rooted = rooted;
			}
			
		}
		
		private Collection<Edge> edges = new ArrayList<Edge>();
		private Collection<Node> nodes = new ArrayList<Node>();
		private Map<String,Node> nodeMap = new HashMap<String,Node>();
		private Map<String,OpsResult> opsMap;
		static String UNROOTED_ERR_MSG  = "Set of unrooted connectors in overconstrained connection graph:";
		static String MULTIROOT_ERR_MSG = "Multiple definite roots in unbreakable subgraph in overconstrained connection graph";
		static String LOOP_ERR_MSG      = "Unbreakable loop in overconstrained connection graph";
		static String MULTIDEF_ERR_MSG  = "Multiple root definitions for single connector in overconstrained connection graph";
		static String ERR_SEP = "\n    ";
		
		/**
		 * Add a connection to the graph.
		 * 
		 * @param left    describes one end of connection
		 * @param right   describes other end of connection
		 * @param prefix  the prefix to use when flattening names
		 * @param source  the originating connect or branch statement
		 */
		public void addConnection(ConnectionSetEntry left, ConnectionSetEntry right, FAccess prefix, ConnectionEdge source) {
			Node leftNode = getNode(left.name(), left.getVar());
			Node rightNode = getNode(right.name(), right.getVar());
			edges.add(new Edge(source, leftNode, rightNode, left, right, prefix));
		}
		
		/**
		 * Mark a component as a root in the graph.
		 */
		public void addRoot(InstComponentDecl var) {
			getNode(var).setRoot();
		}
		
		/**
		 * Mark a component as a potential root with the given priority in the graph.
		 */
		public void addPotentialRoot(InstComponentDecl var, int priority) {
			getNode(var).setPotentialRoot(priority);
		}

        /**
         * Convert graph to a set of spanning trees.
         * 
         * See Modelica Language Specification 3.3, section 9.4.2.
         */
        public void buildTrees(ConnectionSetManager csm) {
            breakPureConnectLoops();
            Queue<Node> roots = collectRoots();
            java.util.List<Node> selected = new ArrayList<Node>(roots.size());
            if (selectRoots(roots, selected))
                return;
            
            buildTrees(csm, selected);
            unrootedErrors();
            buildOpsMap();
        }

        /**
         * Break loops comprised entirely of connect edges.
         */
        private void breakPureConnectLoops() {
            for (Node n : nodes) {
                n.breakPureConnectLoops();
            }
        }

        /**
         * Collect roots sorted by priority.
         */
        private Queue<Node> collectRoots() {
            Queue<Node> roots = new PriorityQueue<Node>();
            for (Node n : nodes)
                if (n.canBeRoot())
                    roots.add(n);
            return roots;
        }

        /**
         * Select a root for each unbreakable sub-graph, and generate any root-related errors.
         * 
         * @param roots     list of roots sorted in priority order
         * @param selected  list where the selected roots will be added
         * @return  true if any errors were generated
         */
        private boolean selectRoots(Queue<Node> roots, java.util.List<Node> selected) {
            clearVisited();
            boolean foundError = false;
            java.util.List<Node> otherRoots = new ArrayList<Node>();
            for (Node root = roots.poll(); root != null; root = roots.poll()) {
                if (!root.visited) {
                    boolean loop = root.markSelectedRoot(root, otherRoots);
                    selected.add(root);
                    
                    // Generate errors for unbreakable loops.
                    if (loop) {
                        genError(LOOP_ERR_MSG, root, "Selected root: ");
                        foundError = true;
                    }
                    // Generate errors for multiple roots.
                    if (otherRoots.size() > 0) {
                        genError(MULTIROOT_ERR_MSG, root, "Selected root: ", otherRoots, "Other root: ");
                        otherRoots = new ArrayList<Node>();
                        foundError = true;
                    }
                }
            }
            return foundError;
        }

        /**
         * Build spanning trees from graph, starting from selected roots.
         */
        private void buildTrees(ConnectionSetManager csm, java.util.List<Node> selected) {
            clearVisited();
            for (Node sel : selected) {
                if (!sel.visited) {
                    Queue<Node> work = new ArrayDeque<Node>();
                    work.add(sel);
                    sel.level = 0;
                    sel.visited = true;
                    for (Node n = work.poll(); n != null; n = work.poll()) {
                        n.buildTree(work, csm);
                    }
                }
            }
        }

        /**
         * Generate errors for subgraphs without roots.
         */
        private void unrootedErrors() {
            for (Node n : nodes) {
                if (!n.visited) {
                    ArrayList<Node> subGraph = new ArrayList<Node>();
                    n.subGraph(subGraph);
                    genError(UNROOTED_ERR_MSG, n, subGraph, null);
                }
            }
        }

        /**
         * Build lookup map for operators that are dependent on the result.
         */
        private void buildOpsMap() {
            opsMap = new HashMap<String,OpsResult>();
            for (Node n : nodes) 
                opsMap.put(n.flatName(), n.opsResult());
        }

        /**
         * Clear visited flags.
         */
        private void clearVisited() {
            for (Node n : nodes)
                n.visited = false;
            for (Edge e : edges)
                e.visited = false;
        }

        /**
         * Generate error message.
         */
        private void genError(String msg, Node node, 
                java.util.List<Node> nodeList, String listMsg) {
            genError(msg, node, null, nodeList, listMsg);
        }

        /**
         * Generate error message.
         */
        private void genError(String msg, Node node, String nodeMsg) {
            genError(msg, node, nodeMsg, null, null);
        }

        /**
         * Generate error message.
         */
        private void genError(String msg, Node node, String nodeMsg, 
                java.util.List<Node> nodeList, String listMsg) {
            StringBuilder errorMsg = new StringBuilder();
            errorMsg.append(msg);
            if (nodeMsg != null) {
                errorMsg.append(ERR_SEP);
                errorMsg.append(nodeMsg);
                errorMsg.append(node.flatName());
            }
            if (nodeList != null) {
                for (Node n : nodeList) {
                    errorMsg.append(ERR_SEP);
                    if (listMsg != null) {
                        errorMsg.append(listMsg);
                    }
                    errorMsg.append(n.flatName());
                }
            }
            node.var.error(errorMsg.toString());
        }

		/**
		 * Check if conversion to spanning trees is finished.
		 */
		public boolean builtTreesDone() {
			return opsMap != null;
		}
		
		/**
		 * Find the result for operators that depend on the graph for the given access.
		 */
		public OpsResult ops(FExp e) {
			OpsResult res = null;
            CommonAccess u = e.asCommonAccess();
			if (u.isInstAccess()) {
                InstComponentDecl var = u.asInstAccess().myInstComponentDecl();
				Node n = getNode(var);
				res = (n == null) ? null : n.opsResult();
			} else {
                res = opsMap.get(u.name());
			}
			return (res == null) ? new OpsResult(false, false) : res;
		}
		
		/**
		 * Remove all references to the instance tree, and discard information that is no longer needed.
		 */
		public void disconnectFromInstanceTree() {
			edges = null;
			nodes = null;
			nodeMap = null;
		}

        /**
         * Find, or if neccessary create, the node for a given component.
         */
        private Node getNode(InstComponentDecl var) {
            return getNode(var.getFAccess().name(), var);
        }

        /**
         * Find, or if neccessary create, the node for a given component accessed by the specified name.
         */
        private Node getNode(String name, InstComponentDecl var) {
            Node res = nodeMap.get(name);
            if (res == null) {
                res = new Node(var, name);
                nodeMap.put(name, res);
                nodes.add(res);
            }
            return res;
        }

		/**
		 * An edge in the graph.
		 */
		private static class Edge {
			
			/** Visited flag used in traversals. */
			public boolean visited;

			private ConnectionEdge source;
			private Node n1;
			private Node n2;
			private ConnectionSetEntry cse1;
			private ConnectionSetEntry cse2;
			private FAccess prefix;
			private boolean broken;
			private boolean ignore = false;
			
			/**
			 * Create a new edge.
			 * 
			 * The edge is undirected, use of "first" and "second" below is purely to tell them apart.
			 * 
			 * @param source  the originating connect or branch statement
			 * @param n1      first end of the edge
			 * @param n2      second end of the edge
			 * @param cse1    describes first end of edge in terms of the connection set manager
			 * @param cse2    describes second end of edge in terms of the connection set manager
			 * @param prefix  the prefix to use when flattening names
			 */
			public Edge(ConnectionEdge source, Node n1, Node n2, ConnectionSetEntry cse1, ConnectionSetEntry cse2, FAccess prefix) {
				this.source = source;
				this.n1 = n1;
				this.n2 = n2;
				n1.addEdge(this);
				n2.addEdge(this);
				broken = false;
				if (isBreakable()) {
					this.cse1 = cse1;
					this.cse2 = cse2;
					this.prefix = prefix;
				}
			}
			
			/**
			 * Check if this is a breakable edge (a connect() statement).
			 */
			public boolean isBreakable() {
				return source.isBreakable();
			}
            
            public String toString() {
                return n1 + " - " + n2;
            }
			
			/**
			 * Get the other end of the edge.
			 * 
			 * Assumes that n is one of the ends.
			 */
			public Node other(Node n) {
				return (n == n1) ? n2 : n1;
			}
			
			/**
			 * Checks if the given node is the edge corresponding to the left argument of a 
			 * connect or branch.
			 */
			public boolean isLeft(Node n) {
				return n == n1;
			}
			
			/**
			 * Break this edge.
			 * 
			 * @throws UnsupportedOperationException  if the edge isn't breakable
			 */
			public void breakEdge() {
				if (!isBreakable())
					throw new UnsupportedOperationException();
				broken = true;
			}
			
			/**
			 * Check if edge is broken.
			 */
			public boolean isBroken() {
				return broken;
			}
			
			/**
			 * Add edge to connection sets, either as normal connections or as equalityConstraint() calls.
			 */
			public void connect(ConnectionSetManager csm) {
				if (isBreakable()) {
					if (isBroken())
						csm.addEqualityConstraint(cse1, cse2, prefix);
					else
						cse1.getVar().connectTo(cse1, cse2, prefix, csm, source, false);
				}
			}

            /**
             * Checks if this edge should be ignored during computations
             */
            public boolean isIgnored() {
                return ignore;
            }

            /**
             * Marks this edge as ignored and will not be considered during computations
             */
            public void setAsIgnored() {
                ignore = true;
            }

		}

        /**
         * A node in the graph.
         */
        private static class Node implements Comparable<Node> {

            /** Visited flag used in traversals. */
            public boolean visited = false;
            /** Depth of this node from root of tree. Depth 0 is the root. */
            public int level = -1;

            private static final int DEFINITE_ROOT = -1;
            private static final int NOT_ROOT      = Integer.MAX_VALUE;

            private InstComponentDecl var;
            private String name;
            private int rootPriority;
            private Collection<Edge> edges;
            private Node selectedRoot;

            public Node(InstComponentDecl var, String name) {
                this.var = var;
                this.name = name;
                rootPriority = NOT_ROOT;
                edges = new ArrayList<Edge>();
                selectedRoot = null;
            }

            public int compareTo(Node other) {
                return rootPriority - other.rootPriority;
            }

            public String toString() {
                return name;
            }

            public void addEdge(Edge e) {
                edges.add(e);
            }

            /**
             * Check if this node is declared either root or potential root.
             */
            public boolean canBeRoot() {
                return rootPriority != NOT_ROOT;
            }

            /**
             * Check if this node was selected as a root during conversion to spanning trees.
             * 
             * Returns false before conversion.
             */
            public boolean isSelectedRoot() {
                return level == 0;
            }

            /**
             * The flattened name of the node, as a String.
             */
            public String flatName() {
                return name;
            }

            /**
             * Mark this node as a potential root with the given priority.
             */
            public void setPotentialRoot(int priority) {
                if (rootPriority < NOT_ROOT && rootPriority != priority) {
                    // Error - Multiple root definitions of a connector 
                    StringBuilder errorMsg = new StringBuilder();
                    errorMsg.append(MULTIDEF_ERR_MSG);
                    errorMsg.append(ERR_SEP);
                    errorMsg.append("Connector: ");
                    errorMsg.append(this.flatName());
                    var.error(errorMsg.toString());
                }
                if (rootPriority > priority)
                    rootPriority = priority;
            }

            /**
             * Mark this node as a definite root.
             */
            public void setRoot() {
                setPotentialRoot(DEFINITE_ROOT);
            }

            /**
             * Calculate the results of isRoot() and rooted() when applied to this node.
             */
            public OpsResult opsResult() {
                Node other = null;
                for (Edge e : edges)
                    if (!e.isIgnored() && e.isLeft(this) && !e.isBreakable())
                        other = e.other(this);
                boolean rooted = other != null && level < other.level;
                return new OpsResult(isSelectedRoot(), rooted);
            }

            /** 
             * Traversal method for building the spanning trees.
             */
            public void buildTree(Queue<Node> work, ConnectionSetManager csm) {
                for (Edge e : edges) 
                    if (!e.isIgnored() && !e.visited) 
                        buildTreeVisit(e, work, csm);
            }

            /** 
             * Traversal method for decending into unbreakable subgraphs when building the spanning trees.
             */
            private void buildTreeForUnbreakable(Queue<Node> work, ConnectionSetManager csm) {
                for (Edge e : edges) 
                    if (!e.isIgnored() && !e.visited && !e.isBreakable()) 
                        buildTreeVisit(e, work, csm);
            }

            /**
             * Visit a specific edge during traversal for building the spanning trees.
             */
            private void buildTreeVisit(Edge e, Queue<Node> work, ConnectionSetManager csm) {
                e.visited = true;
                Node n = e.other(this);
                if (n.visited) {
                    e.breakEdge();
                } else if (n.selectedRoot != selectedRoot) {
                    if (n.selectedRoot != null && n.selectedRoot.rootPriority == DEFINITE_ROOT)
                        e.breakEdge();
                    else
                        n.selectedRoot = selectedRoot;
                }
                n.visited = true;
                e.connect(csm);
                if (!e.isBroken()) {
                    n.level = level + 1;
                    work.add(n);
                    n.buildTreeForUnbreakable(work, csm);
                }
            }

            /**
             * Find and break loops consisting only of connect edges.
             */
            public void breakPureConnectLoops() {
                if (!visited) {
                    visited = true;
                    for (Edge e : edges) {
                        if (!e.isIgnored() && !e.visited && e.isBreakable()) {
                            e.visited = true;
                            Node n = e.other(this);
                            if (n.visited) {
                                e.setAsIgnored();
                            } else {
                                n.breakPureConnectLoops();
                            }
                        }
                    }
                }
            }

            /**
             * Set the selected root of this subgraph.
             * @param root        the selected root node
             * @param otherRoots  a collection to add any redundant roots to
             * @return true if unbreakable loop found
             */
            public boolean markSelectedRoot(Node root, Collection<Node> otherRoots) {
                boolean loop = false;
                visited = true;
                selectedRoot = root;
                if (root != this && rootPriority == DEFINITE_ROOT) {
                    // Error - more than one definite root in unbreakable subgraph
                    otherRoots.add(this);
                }
                
                for (Edge e : edges) {
                    if (!e.isIgnored() && !e.visited && !e.isBreakable()) {
                        e.visited = true;
                        Node n = e.other(this);
                        if (n.visited) {
                            // Error - unbreakable loop
                            loop = true;
                        }
                        loop = loop || n.markSelectedRoot(root, otherRoots);
                    }
                }
                return loop;
            }

            /**
             * Gathers the subgraph which n is in.
             */
            public void subGraph(ArrayList<Node> sg) {
                if (visited)
                    return;
                visited = true;
                sg.add(this);
                for (Edge e : edges) {
                    if (!e.isIgnored()) {
                        e.other(this).subGraph(sg);
                    }
                }
            }

        }

    }

}

aspect ExpandableConnectors {
    
    public class ExpandableConnectorSets {
        
        private Map<InstComponentDecl,ExpandableSet> map;
        private Set<ExpandableSet> sets;
        private java.util.List<Connection> connections;
        private java.util.List<InstAccess> uses;
        private boolean expansionDone;

        
        public ExpandableConnectorSets() {
            map = new LinkedHashMap<>();
            sets = new LinkedHashSet<>();
            connections = new ArrayList<>();
            uses = new ArrayList<>();
            expansionDone = false;
        }
        
        /**
         * Calculate the components present in each expandable connector and apply connections 
         * involving them.
         */
        public void elaborate(ConnectionSetManager csm) {
            boolean ok = true;
            for (ExpandableSet set : sets()) 
                set.addNested();
            for (ExpandableSet set : sets()) 
                if (!set.expand())
                    ok = false;
            
            if (ok) {
                expansionDone = true;
                for (Connection conn : connections) {
                    conn.connect(csm);
                }
                for (InstComponentDecl icd : map.keySet()) {
                    icd.buildConnectionSets(null, csm, true);
                    icd.getInstComponentDecls().collectErrors(ErrorCheckType.GENERATED);
                }
                for (InstAccess use : uses) {
                    use.flushAllRecursiveClearFinal();
                    if (use.myInstComponentDecl().isUnknown()) 
                        use.error("Using member of expandable connector is only allowed if the member is connected to in the connection set");
                }
            }
        }
        
        /**
         * Add an expandable connector to sets.
         */
        public void addConnector(InstComponentDecl conn) {
            setFor(conn);
        }
        
        /**
         * Add a use of a member of an expandable connector.
         */
        public void addUse(InstAccess use) {
            uses.add(use);
        }

        /**
         * Add information about a connection introducing a new component to an expandable connector.
         */
        public void addIntroducingConnection(InstAccess unknown, InstAccess known,
                FAccess prefix, ConnectionEdge source) {
            InstComponentDecl expandable = unknown.findReferencedExpandableConnector();
            InstAccess unknownPart = unknown.findExpandableMemberPart(expandable);
            ExpandableSet set = setFor(expandable);
            set.addMember(known, unknown, unknownPart);
            
            connections.add(new Connection(prefix, source));
            // TODO: support adding nestled expandable connectors? see Modelica:#428
       }

        /**
         * Add information about a connection between two expandable connectors.
         */
        public void addSpanningConnection(InstComponentDecl leftComp, InstComponentDecl rightComp,
                FAccess prefix, ConnectionEdge source) {
            connectExpandableConnectors(leftComp, rightComp);
            connections.add(new Connection(prefix, source));
        }

        /**
         * Check if elaboration is already done.
         */
        public boolean isExpansionDone() {
            return expansionDone;
        }
        
        private void connectExpandableConnectors(InstComponentDecl leftComp, InstComponentDecl rightComp) {
            ExpandableSet left = setFor(leftComp);
            ExpandableSet right = setFor(rightComp);
            left.merge(right);
            
            SortedSet<InstComponentDecl> rightChildren = rightComp.containedInstComponents();
            for (InstComponentDecl leftChild : leftComp.containedInstComponents()) {
                if (leftChild.isExpandableConnector() && rightChildren.contains(leftChild)) {
                    InstComponentDecl rightChild = rightChildren.tailSet(leftChild).first();
                    if (rightChild.isExpandableConnector())
                        connectExpandableConnectors(leftChild, rightChild);
                }
            }
        }
        
        /**
         * Add a new binding to the map and the list of sets to process.
         */
        private void bind(InstComponentDecl conn, ExpandableSet set) {
            map.put(conn, set);
            sets.add(set);
        }
        
        private ExpandableSet setFor(InstComponentDecl comp) {
            InstComponentDecl org = comp.duplicateOriginal();
            ExpandableSet set = map.get(org);
            if (set == null) {
                set = new ExpandableSet(org);
            }
            if (org != comp) {
                set.addConnector(comp);
            }
            return set;
        }

        private Iterable<ExpandableSet> sets() {
            return new GrowableSetIterable(sets);
        }

        private class Connection {
            
            public final FAccess prefix;
            public final FConnectClause source;
            private EvaluataionValueCache values;
            
            public Connection(FAccess prefix, ConnectionEdge source) {
                this.prefix = prefix;
                this.source = (FConnectClause) source;
                values = new EvaluataionValueCache(this.source);
            }
            
            public void connect(ConnectionSetManager csm) {
                source.flushAllRecursiveClearFinal(); // Depends on FConnectClause not resetting is$Final
                values.apply();
                source.buildConnectionSets(prefix, csm, true);
                values.reset();
            }
            
            public String toString() {
                return source.toString();
            }
            
        }
        
        private class ExpandableSet {
            
            private Set<InstComponentDecl> connectors;
            private Set<ExpandableSet> parentSets;
            private Map<String,ConnectorMember> members;
            private Set<ConnectorMember> owningMembers;
            private ExpandableSet replacement = null;
            private boolean expanded;
            private boolean nestedDone;
            private boolean isok;
            
            public ExpandableSet() {
                connectors = new LinkedHashSet<InstComponentDecl>();
                parentSets = new HashSet<ExpandableSet>();
                members = new HashMap<String,ConnectorMember>();
                owningMembers = new HashSet<ConnectorMember>();
                expanded = false;
                nestedDone = false;
                isok = true;
            }
            
            public ExpandableSet(InstComponentDecl connector) {
                this();
                addConnector(connector);
            }
            
            public ExpandableSet(ConnectorMember member) {
                this();
                owningMembers.add(member);
            }
            
            /**
             * Calculate the components present in each expandable connector, if not already done.
             * 
             * @return  <code>false</code> if any errors were found
             */
            public boolean expand() {
                if (!expanded) {
                    expanded = true;
                    for (ExpandableSet parentSet : parentSets()) {
                        parentSet.expand();
                    }
                    
                    ConnectorMember[] sorted = members.values().toArray(new ConnectorMember[members.size()]);
                    Arrays.sort(sorted);
                    for (ConnectorMember member : sorted) {
                        isok = member.check() && isok;
                    }
                    if (isok) { 
                        for (InstComponentDecl conn : connectors()) {
                            expandConnector(conn, sorted);
                        }
                    }
                }
                return isok;
            }

            private Iterable<InstComponentDecl> connectors() {
                return new GrowableSetIterable(connectors);
            }

            /**
             * Add all nested expandable connector to their parent's sets.
             */
            public void addNested() {
                if (!nestedDone && !members.isEmpty()) {
                    nestedDone = true;
                    for (InstComponentDecl conn : connectors) {
                        InstComponentDecl p = conn.findExpandableAncestor();
                        if (p != null) {
                            InstComponentDecl c = conn.ancestorChild(p, conn);
                            ExpandableSet set = setFor(p);
                            set.addDeclared(c.name());
                            set.addNested();
                        }
                    }
                }
            }
            
            /**
             * Merge two sets of expandable connectors, keeping this one.
             */
            public void merge(ExpandableSet other) {
                if (other == null || other == this)
                    return;
                
                for (InstComponentDecl conn : other.connectors) {
                    addConnector(conn);
                }
                other.replaceWith(this);
                
                parentSets().addAll(other.parentSets());
                
                for (ConnectorMember member : other.members.values()) {
                    ConnectorMember local = members.get(member.name);
                    if (local == null) {
                        local = new ConnectorMember(member);
                        local.addParentSet(this);
                        members.put(local.name, local);
                    } else {
                        local.merge(member);
                    }
                    local.removeParentSet(other);
                }
                
                for (ConnectorMember member : other.owningMembers) {
                    owningMembers.add(member);
                    member.replaceSet(this);
                }
            }
            
            private ExpandableSet actual() {
                if (replacement == null) {
                    return this;
                } else {
                    replacement = replacement.actual();
                    return replacement;
                }
            }
            
            private void replaceWith(ExpandableSet other) {
                replacement = other.actual();
                // Don't process this set
                expanded = true;
                nestedDone = true;
            }
            
            /**
             * Add a member to the connectors of the set, possibly as expandable connector members 
             * that members are recursively added to.
             */
            public void addMember(InstAccess source, InstAccess unknown, InstAccess unknownPart) {
                String name = unknownPart.name();
                ConnectorMember member = members.get(name);
                if (unknownPart == unknown.getLastInstAccess()) {
                    FArraySubscripts fas = unknownPart.hasFArraySubscripts() ? unknownPart.getFArraySubscripts() : null;
                    if (member == null) {
                        member = new ConnectorMember(name, source, fas);
                        members.put(name, member);
                    } else {
                        member.addConnection(source, fas);
                    }
                } else {
                    // TODO: probably need more to support arrays in this case
                    if (member == null) {
                        member = new ConnectorMember(name, unknown);
                        members.put(name, member);
                    }
                    member.set().addMember(source, unknown, unknownPart.getNextInstAccess());
                }
                member.addParentSet(actual());
            }
            
            /**
             * Add a declared member to the connectors of the set.
             * 
             * This is only used to include nested expandable connectors.
             */
            public void addDeclared(String name) {
                ConnectorMember member = members.get(name);
                if (member == null) 
                    members.put(name, new ConnectorMember(name));
            }
            
            /**
             * Add a duplicate version of the expandable connector.
             * 
             * All encountered duplicate versions are expanded.
             */
            public void addConnector(InstComponentDecl connector) {
                connectors.add(connector);
                bind(connector, this);
            }
            
            /**
             * Add another set as a parent to this one.
             * 
             * All parent sets will be expanded before this one.
             */
            public void addParentSet(ExpandableSet parentSet) {
                parentSets.add(parentSet);
            }

            /**
             * Remove another set from list of parents.
             */
            public void removeParentSet(ExpandableSet parentSet) {
                parentSets.remove(parentSet);
            }
            
            /**
             * Get the list of sets that need to be expanded before this one, 
             * updated for replacements.
             */
            private Set<ExpandableSet> parentSets() {
                boolean replace = false;
                for (ExpandableSet parent : parentSets) {
                    replace |= parent.replacement != null;
                }
                if (replace) {
                    Set<ExpandableSet> replacement = new HashSet<>();
                    for (ExpandableSet parent : parentSets) {
                        replacement.add(parent.actual());
                    }
                    parentSets = replacement;
                }
                return parentSets;
            }
            
            /**
             * Create a list with the components each connector in this set should have.
             * 
             * @param members  the members of this set, sorted by name
             */
            public void expandConnector(InstComponentDecl parent, ConnectorMember[] members) {
                List<InstComponentDecl> memberList = new List<InstComponentDecl>();
                memberList.setParent(parent); // Make sure inherited attributes work at once
                InstComponentDecl[] templates = new InstComponentDecl[members.length];
                int i = 0;
                for (ConnectorMember member : members) {
                    memberList.add(member.createInstComponent(parent));
                    templates[i++] = member.template(parent);
                }
                parent.expandConnector(memberList, templates);
            }
            
            /**
             * Check if the given expandable set describes a set of connectors that will contain 
             * one of the connectors described by this set (directly or indirectly).
             */
            private boolean isOrAncestor(ExpandableSet other) {
                return other == this || isOrAncestorHelper(other, new HashSet<ExpandableSet>());
            }
            
            private boolean isOrAncestorHelper(ExpandableSet other, Set<ExpandableSet> visited) {
                /* If we have already been here, we either have a loop among the ancestors, 
                 * or a diamond pattern in the graph. Neither case means that there is a loop 
                 * involving other.
                 */
                if (visited.add(this)) {
                    for (ExpandableSet parent : parentSets) {
                        if (parent == other || parent.isOrAncestorHelper(other, visited)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            public String toString() {
                StringBuilder buf = new StringBuilder("Connectors:");
                for (InstComponentDecl c : connectors) {
                    buf.append("\n  ");
                    buf.append(c.qualifiedName());
                }
                buf.append("\nMembers:");
                for (ConnectorMember m : members.values()) {
                    buf.append("\n  ");
                    buf.append(m.name);
                }
                return buf.toString();
            }
            
            private class ConnectorMember implements Comparable<ConnectorMember> {
                
                public final String name;
                private ExpandableSet set;
                private java.util.List<Source> sources;
                private java.util.List<InstAccess> nestledAccesses;
                private InstComponentDecl template;
                private Map<InstComponentDecl,InstComponentDecl> templateMap;
                private FArraySubscripts subscripts;
                private boolean error;
                private boolean calculated;
                
                public ConnectorMember(String name) {
                    this.name = name;
                    sources = new ArrayList<Source>(4);
                    nestledAccesses = new ArrayList<InstAccess>(2);
                    template = null;
                    templateMap = null;
                    subscripts = null;
                    calculated = false;
                    error = false;
                }
                
                public ConnectorMember(String name, InstAccess target, FArraySubscripts fas) {
                    this(name);
                    addConnection(target, fas);
                }
                
                public ConnectorMember(String name, InstAccess unknown) {
                    this(name);
                    nestledAccesses.add(unknown);
                }
                
                public ConnectorMember(ConnectorMember other) {
                    this(other.name);
                    merge(other);
                    nestledAccesses = other.nestledAccesses;
                }
                
                public int compareTo(ConnectorMember other) {
                    return name.compareTo(other.name);
                }
                
                public void addConnection(InstAccess target, FArraySubscripts fas) {
                    sources.add(new Source(target, fas));
                    InstComponentDecl targetVar = target.myInstComponentDecl();
                    ExpandableSet otherSet = map.get(targetVar);
                    if (otherSet == null && targetVar.isExpandableConnector()) {
                        if (set == null) {
                            set = setFor(targetVar);
                        } else {
                            set().addConnector(targetVar);
                        }
                    } else {
                        if (set == null) {
                            set = otherSet;
                        } else {
                            set().merge(otherSet);
                        }
                    }
                }
                
                public void merge(ConnectorMember other) {
                    if (set == null) {
                        set = other.set;
                    } else if (other.set != null) {
                        set().merge(other.set());
                    }
                    for (Source s : other.sources) {
                        sources.add(new Source(s));
                    }
                }
                
                public ExpandableSet set() {
                    if (set == null) {
                        set = new ExpandableSet(this);
                    }
                    set = set.actual();
                    return set;
                }
                
                public void replaceSet(ExpandableSet newSet) {
                    set = newSet;
                }
                
                public void addParentSet(ExpandableSet parentSet) {
                    if (set != null) {
                        set().addParentSet(parentSet);
                    }
                }
                
                public void removeParentSet(ExpandableSet parentSet) {
                    if (set != null) {
                        set().removeParentSet(parentSet);
                    }
                }
                
                /**
                 * Check if all connections to this member are consistent.
                 * 
                 * @return  <code>false</code> if any errors were found
                 */
                public boolean check() {
                    if (!calculated)
                        calculateVariable();
                    return !error;
                }
                
                public InstComponentDecl createInstComponent(InstComponentDecl parent) {
                    InstComponentDecl tmpl = template(parent);
                    InstComponentDecl res;
                    if (tmpl.name().equals(name) && tmpl.isChildOf(parent)) {
                        if (subscripts() != null) {
                            tmpl.setLocalFArraySubscripts(subscripts());
                        }
                        res = tmpl;
                    } else {
                        SrcComponentDecl cd = tmpl.getSrcComponentDecl();
                        res = tmpl.myInstClass().newInstComponentDeclCopy(
                                name, subscripts(), cd, cd.getClassName());
                    }
                    if (tmpl.isExpandableConnector()) {
                        ExpandableSet set2 = setFor(tmpl);
                        set2.addConnector(res);
                        if (set != null) {
                            set().merge(set2);
                        }
                    }
                    return res;
                    // TODO: handle input/output (or is that really needed?)
                }
                
                private InstComponentDecl template(InstComponentDecl parent) {
                    if (!calculated) {
                        calculateVariable();
                    }
                    if (templateMap != null) {
                        InstComponentDecl declared = templateMap.get(parent);
                        if (declared != null) {
                            return declared;
                        }
                    }
                    return template;
                }
                
                private FArraySubscripts subscripts() {
                    if (!calculated)
                        calculateVariable();
                    return subscripts;
                }
                
                private void calculateVariable() {
                    error = false;
                    
                    // Check for recursive structure first.
                    if (set != null) {
                        for (Source src : sources) {
                            if (!src.checkRecursion(ExpandableSet.this)) {
                                error = true;
                            }
                        }
                        if (error) {
                            return;  // We risk infinite recursion if we continue
                        }
                    }
                    
                    // Collect instances of this member from declarations
                    ArrayList<InstComponentDecl> declared = new ArrayList<InstComponentDecl>();
                    Map<InstComponentDecl,InstComponentDecl> declaredMap = new HashMap<>();
                    for (InstComponentDecl conn : connectors) {
                        InstLookupResult<InstComponentDecl> res = conn.memberInstComponent(name);
                        if (res.successful()) {
                            InstComponentDecl decl = res.target();
                            declared.add(decl);
                            declaredMap.put(conn, decl);
                        }
                    }
                    
                    // Pick a variable to use as template
                    ASTNode templateErrorNode = null;
                    if (sources.isEmpty() && declared.isEmpty()) {
                        error = true;
                        for (InstAccess nestledAccess : nestledAccesses)
                            nestledAccess.compliance("Nested expandable connectors where some of the intermediate expandable connectors are neither connected to or declared are not supported");
                    } else if (declared.isEmpty()) {
                        template = sources.get(0).template();
                        templateErrorNode = sources.get(0).errorNode();
                    } else {
                        template = declared.get(0);
                        templateErrorNode = template;
                        templateMap = declaredMap;
                    }
                    
                    // Check types against template
                    if (template != null && !template.checkAsExpandableMemberTemplate(templateErrorNode))
                        error = true;
                    for (Source src : sources)
                        src.checkType(template);
                    for (InstComponentDecl decl : declared) {
                        if (!decl.connectableTypes(template)) {
                            error = true;
                            decl.error("Type of declared member of expandable connector does not match declarations in other expandable connectors in same connection set");
                        }
                    }
                    
                    // Calculate size
                    SummedSize ss = new SummedSize();
                    for (InstComponentDecl decl : declared)
                        ss.updateFromDeclaration(decl);
                    for (Source src : sources)
                        src.collectSize(ss);
                    Size s = ss.size;
                    if (template != null && template.ndims() > template.localNdims()) {
                        s = s.contract(0, template.ndims() - template.localNdims());
                    }
                    
                    // Create subscripts for size
                    if (s != Size.SCALAR && s != null) {
                        subscripts = s.createFArrayExpSubscripts();
                    }
                    
                    // Check against connections to non-existing members of non-expandable connectors
                    if (!sources.isEmpty() && set != null && set().connectors.isEmpty() && !set().members.isEmpty()) 
                        for (ConnectorMember m : set().members.values())
                            error = !m.checkNonExisting(template) || error;
                    
                    // Check array index types. If there is a declaration they are checked in FExpSubscript.typeCheckAsIndex;
                    if (declared.isEmpty()) {
                        Source tmpl = null;
                        for (Source src : sources) {
                            if (tmpl == null)
                                tmpl = src;
                            if (!src.checkIndexType(tmpl))
                                break;
                        }
                    }
                    calculated = true;
                }
                
                private boolean checkNonExisting(InstComponentDecl parentTemplate) {
                    boolean res = true;
                    InstComponentDecl myTemplate = (parentTemplate != null) ? parentTemplate.memberInstComponent(name).targetOrNull() : null;
                    if (myTemplate == null) {
                        for (Source s : sources)
                            s.errorNode().error("Can not connect to non-existing member of non-expandable connector in expandable connector");
                        res = false;
                    }
                    if (set != null) 
                        for (ConnectorMember m : set().members.values())
                            res = m.checkNonExisting(myTemplate) && res;
                    return res;
                }
                
                public String toString() {
                    return name + ": " + sources.toString();
                }
                
                private class Source {
                    
                    private InstAccess target;
                    private FArraySubscripts fas;
                    private boolean errorReported = false;
                    
                    private Size s;
                    private boolean[] fixed;
                    
                    public Source(InstAccess target, FArraySubscripts fas) {
                        this.target = target;
                        this.fas = fas;
                        calculateSize();
                    }
                    
                    public Source(Source other) {
                        this.target = other.target;
                        this.fas = other.fas;
                        this.s      = other.s;
                        this.fixed  = other.fixed;
                    }
                    
                    private void calculateSize() {
                        // Calculate local size
                        Size ts = target.size();
                        if (fas != null) {
                            MutableSize ms = new MutableSize(fas.ndims());
                            fixed = new boolean[ms.ndims()];
                            int tspos = 0;
                            for (int i = 0; i < fixed.length; i++) {
                                Subscript sub = fas.subscript(i);
                                int len = (tspos < ts.ndims()) ? ts.get(tspos) : 1;
                                if (!sub.calculateExpandableConnectorSize(ms, i, len)) 
                                    localError();
                                fixed[i] = sub.isColon();
                                if (sub.ndims() > 0) 
                                    tspos++;
                            }
                            if (tspos != ts.ndims())
                                localError();
                            s = ms;
                        } else {
                            s = (ts == Size.SCALAR) ? ts : ts.mutableClone();
                            fixed = new boolean[s.ndims()];
                            Arrays.fill(fixed, true);
                        }
                    }
                    
                    public void collectSize(SummedSize ss) {
                        if (errorReported)
                            return;
                        
                        // Merge with other sizes in set
                        if (!ss.merge(s, fixed))
                            mismatchError();
                   }
                    
                    public void checkType(InstComponentDecl template) {
                        if (!target.myInstComponentDecl().connectableTypes(template))
                            error("Type of component introduced to external connector does not match other connections to same name in connection set or component declared in connector");
                    }
                    
                    public boolean checkIndexType(Source other) {
                        if (fas == null || other.fas == null)
                            return true;
                        for (int dim = 0; dim < Math.min(fas.ndims(), other.fas.ndims()); dim++) {
                            if (!fas.subscript(dim).type().scalarType().typeCompatible(
                                    other.fas.subscript(dim).type().scalarType())) {
                                error("Array index type of component introduced to external connector does not match other"
                                        + " connections to same name in connection set");
                                return false;
                            }
                        }
                        return true;
                    }
                    
                    public boolean checkRecursion(ExpandableSet parent) {
                        ExpandableSet ancestor = map.get(target.myInstComponentDecl());
                        if (ancestor != null && parent.isOrAncestor(ancestor)) {
                            error("Connect introduces a copy of " + target + 
                                  " into a connector that is (possibly indirectly) connected back to " + target + 
                                  ". This creates an infinite recursive structure, and is not allowed:\n    " + 
                                  errorNode());
                            return false;
                        }
                        return true;
                    }
                    
                    private void mismatchError() {
                        error("Size introduced for external connector member does not match other connections to same name in connection set or component declared in connector");
                    }
                    
                    private void localError() {
                        error("Can not match size of connector to access introducing member in external connector");
                    }
                    
                    private void error(String err) {
                        error = true;
                        if (!errorReported) {
                            errorReported = true;
                            errorNode().error(err);
                        }
                    }
                    
                    public InstComponentDecl template() {
                        return target.myInstComponentElement();
                    }
                    
                    public ASTNode errorNode() {
                        return target.getParent();
                    }
                    
                    public String toString() {
                        return target.toString() + ((fas != null) ? (" (" + fas + ")") : "");
                    }
                    
                }
                
                private class SummedSize {
                    
                    public Size size = null;
                    public boolean[] fixed = null;
                    
                    public void updateFromDeclaration(InstComponentDecl icd) {
                        if (!mergeKnownFixed(icd.size())) {
                            error = true;
                            icd.error("Size of declared member of expandable connector does not match declarations in other expandable connectors in same connection set");
                        }
                    }
    
                    private boolean mergeKnownFixed(Size s) {
                        if (s != Size.SCALAR)
                            s = s.mutableClone();
                        boolean[] sFixed = new boolean[s.ndims()];
                        for (int i = 0; i < sFixed.length; i++)
                            sFixed[i] = s.hasValue(i);
                        return merge(s, sFixed);
                    }
    
                    public boolean merge(Size s, boolean[] sFixed) {
                        if (size == null) {
                            size = s;
                            fixed = sFixed;
                        } else if (sFixed.length != fixed.length) {
                            return false;
                        } else {
                            for (int i = 0; i < fixed.length; i++) {
                                int diff = s.get(i) - size.get(i);
                                if (sFixed[i]) {
                                    if (diff == 0) {
                                        fixed[i] = true;
                                    } else if (diff < 0) {
                                        return false;
                                    }
                                } 
                                if (diff > 0) {
                                    if (fixed[i]) {
                                        return false;
                                    } else {
                                        fixed[i] = sFixed[i];
                                        ((MutableSize) size).set(i, s, i);
                                    }
                                }
                            }
                        }
                        return true;
                    }
                    
                }
        }

        }
        
    }
    
    public void InstComponentDecl.expandConnector(List<InstComponentDecl> members, InstComponentDecl[] templates) {
        throw new UnsupportedOperationException();
    }
    
    public void InstExpandableConnectorDecl.expandConnector(List<InstComponentDecl> members, InstComponentDecl[] templates) {
        expandedMembers = members;
        this.templates = templates;
        flushAll();
    }
    
    public void InstReplacingExpandableConnectorDecl.expandConnector(List<InstComponentDecl> members, InstComponentDecl[] templates) {
        expandedMembers = members;
        this.templates = templates;
        flushAll();
    }
    
    public void InstArrayExpandableConnector.expandConnector(List<InstComponentDecl> members, InstComponentDecl[] templates) {
        expandedMembers = members;
        this.templates = templates;
        flushAll();
    }
    
    
    /**
     * Find the closest ancestor component that is an expandable connector, if any.
     */
    inh InstComponentDecl InstComponentDecl.findExpandableAncestor();
    eq InstComponentDecl.getChild().findExpandableAncestor() = 
        (isExpandableConnector() && !isArray()) ? this : findExpandableAncestor();
    eq InstClassDecl.getChild().findExpandableAncestor()     = null;
    eq InstRoot.getChild().findExpandableAncestor()          = null;
    eq Root.getChild().findExpandableAncestor()              = null;
    
    /**
     * Find the ancestor component that is a direct child of the given component.
     * 
     * @param a  the ancestor to find child of
     * @param c  the child being considered, always use <code>this</code>
     */
    inh InstComponentDecl InstComponentDecl.ancestorChild(InstComponentDecl a, InstComponentDecl c);
    eq InstComponentDecl.getChild().ancestorChild(InstComponentDecl a, InstComponentDecl c) = 
        (this == a) ? c : ancestorChild(a, this);
    eq InstClassDecl.getChild().ancestorChild(InstComponentDecl a, InstComponentDecl c)     = null;
    eq InstRoot.getChild().ancestorChild(InstComponentDecl a, InstComponentDecl c)          = null;
    eq Root.getChild().ancestorChild(InstComponentDecl a, InstComponentDecl c)              = null;
    

    private static final BinaryOperation<CValue> FExpSubscript.INT_MAX_OP = new BinaryOperation<CValue>() {
        public CValue op(CValue a, CValue b) { 
            return (a.intValue() >= b.intValue()) ? a : b;
        }
    };
    
    public abstract boolean FSubscript.calculateExpandableConnectorSize(MutableSize s, int i, int len);
    
    public boolean FExpSubscript.calculateExpandableConnectorSize(MutableSize s, int i, int len) {
        CValue val = ceval();
        if (ndims() > 0) 
            val = val.reduce(INT_MAX_OP, new CValueInteger(1));
        s.set(i, val.intValue());
        return ndims() == 0 || size().get(0) == len;
    }
    
    public boolean FIntegerSubscript.calculateExpandableConnectorSize(MutableSize s, int i, int len) {
        s.set(i, getValue());
        return true;
    }
    
    public boolean IntegerSubscript.calculateExpandableConnectorSize(MutableSize s, int i, int len) {
        s.set(i, value);
        return true;
    }
    
    public boolean FColonSubscript.calculateExpandableConnectorSize(MutableSize s, int i, int len) {
        s.set(i, len);
        return true;
    }
    
    /**
     * Check that this component would be allowed as a member of an expandable connector.
     * 
     * @param errorNode  node to report any errors found on
     * @return  <code>true</code> if the component is OK
     */
    public boolean InstComponentDecl.checkAsExpandableMemberTemplate(ASTNode errorNode) {
        for (InstComponentDecl child : getInstComponentDecls()) {
            if (child.isExpandableConnector()) {
                errorNode.compliance("Expandable connectors containing a non-expandable connector component, that in turn contains an expandable connector, is not supported");
                return false;
            } else if (!child.checkAsExpandableMemberTemplate(errorNode))
                return false;
        }
        return true;
    }
    
    public boolean InstExpandableConnectorDecl.checkAsExpandableMemberTemplate(ASTNode errorNode) {
        return true;
    }
    
    public boolean InstReplacingExpandableConnectorDecl.checkAsExpandableMemberTemplate(ASTNode errorNode) {
        return true;
    }
    
    public void InstAccess.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        if (isExpandableConnectorPart())
            csm.getExpandable().addUse(this);
    }
    
    public void InstExpandableConnectorDecl.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        buildConnectionSetsForExpandableConnector(prefix, csm, connect);
    }
    
    public void InstReplacingExpandableConnectorDecl.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        buildConnectionSetsForExpandableConnector(prefix, csm, connect);
    }
    
    public void InstArrayExpandableConnector.buildConnectionSets(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        buildConnectionSetsForExpandableConnector(prefix, csm, connect);
    }
    
    public void InstComponentDecl.buildConnectionSetsForExpandableConnector(FAccess prefix, ConnectionSetManager csm, boolean connect) {
        if (useInFlattening()) {
            if (!isArray()) {
                if (csm.isExpandableConnectorsDone()) {
                    for (InstComponentDecl icd : getInstComponentDecls()) {
                        if (icd.isArray()) {
                            icd.addExpandableArrayMembersTopLevel(csm);
                        }
                    }
                } else {
                    csm.getExpandable().addConnector(this);
                }
            }
            super.buildConnectionSets(prefix, csm, connect);
        }
    }
    
    /**
     * Add all variables to connection set manager, to get "= 0" equations if they are not connected.
     */
    public void InstComponentDecl.addExpandableArrayMembersTopLevel(ConnectionSetManager csm) {
        for (InstComponentDecl icd : allInstComponentDecls()) {
            icd.addExpandableArrayMembers(csm);
        }
    }
    
    public void InstPrimitive.addExpandableArrayMembersTopLevel(ConnectionSetManager csm) {
        if (!variability().parameterOrLess()) {
            for (Index i : indices()) {
                csm.addExpandableArrayMember(this, getFAccess(i));
            }
        }
    }
    
    /**
     * Add all variables to connection set manager, to get "= 0" equations if they are not connected.
     */
    public void InstComponentDecl.addExpandableArrayMembers(ConnectionSetManager csm) {
        for (InstComponentDecl icd : allInstComponentDecls()) {
            icd.addExpandableArrayMembers(csm);
        }
    }
    
    public void InstPrimitive.addExpandableArrayMembers(ConnectionSetManager csm) {
        if (!variability().parameterOrLess()) {
            csm.addExpandableArrayMember(this, getFAccess(Index.NULL));
        }
    }
    
    
    syn boolean InstAccess.isExpandableConnectorPart() = false;
    eq InstDot.isExpandableConnectorPart() {
        InstComponentDecl conn = findReferencedExpandableConnector();
        return conn != null && conn != getLastInstAccess().findReferencedExpandableConnector();
    }
    
    syn InstComponentDecl InstAccess.findReferencedExpandableConnector() = null;
    eq InstComponentAccess.findReferencedExpandableConnector() {
        InstComponentDecl icd = myInstComponentDecl();
        return icd.isExpandableConnector() ? icd : null;
    }
    eq InstComponentArrayAccess.findReferencedExpandableConnector() {
        InstComponentDecl icd = lookupArrayElement(myInstComponentDecl());
        return (icd != null && icd.isExpandableConnector()) ? icd : null;
    }
    eq InstDot.findReferencedExpandableConnector() {
        for (int i = getNumInstAccess() - 1; i >= 0; i--) {
            InstComponentDecl conn = getInstAccess(i).findReferencedExpandableConnector();
            if (conn != null)
                return conn;
        }
        return null;
    }
    
    syn InstAccess InstAccess.findExpandableMemberPart(InstComponentDecl expandable) = null;
    eq InstDot.findExpandableMemberPart(InstComponentDecl expandable) {
        for (int i = getNumInstAccess() - 2; i >= 0; i--) 
            if (getInstAccess(i).findReferencedExpandableConnector() != null)
                return getInstAccess(i + 1);
        return null;
    }
    
    // We need to make sure lookups work properly after flush
    public void InstAmbiguousAccess.flushAllRecursiveClearFinal() {
        super.flushAllRecursiveClearFinal();
        rewritten = false;
        is$Final = false;
    }

    public void InstAmbiguousArrayAccess.flushAllRecursiveClearFinal() {
        super.flushAllRecursiveClearFinal();
        rewritten = false;
        is$Final = false;
    }

}

aspect Cardinality {
    
    private Map<String,Enumerator> ConnectionSetManager.cardinality = null;
    
    public void ConnectionSetManager.countCardinality(String name) {
        if (cardinality == null)
            cardinality = new HashMap<String,Enumerator>();
        Enumerator e = cardinality.get(name);
        if (e == null)
            cardinality.put(name, new Enumerator(1));
        else
            e.next();
    }
    
    public int ConnectionSetManager.getCardinality(String name) {
        if (cardinality == null)
            return 0;
        Enumerator e = cardinality.get(name);
        return (e == null) ? 0 : e.peek();
    }

    // Can only be calculated after flattening - give dummy value before that to prevent error messages about structural parameters for cardinality()
    syn int FExp.cardinalityValue() {
        throw new UnsupportedOperationException();
    }
    eq InstAccessExp.cardinalityValue() = 1;
    eq FAccessExp.cardinalityValue()    = getFAccess().cardinalityValue();

    syn int FAccess.cardinalityValue() = myFClass().getConnectionSetManager().getCardinality(scalarName());

}