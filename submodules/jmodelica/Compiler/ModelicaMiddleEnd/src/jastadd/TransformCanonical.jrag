/*
    Copyright (C) 2009-2017 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//import java.util.ArrayDeque;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Queue;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Collections;
import java.util.Iterator;

import org.jmodelica.util.collections.ListMap;
import org.jmodelica.util.collections.LinkedHashListMap;
import org.jmodelica.util.ErrorCheckType;
import org.jmodelica.util.munkres.DenseMunkresProblem;
import org.jmodelica.util.munkres.IntegerCost;


/* This causes conflicts
import org.jmodelica.graphs.EquationSystem;
import org.jmodelica.graphs.Equation;
import org.jmodelica.graphs.Variable;
*/

/**
 * Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

    /**
     * Transform the raw flattened model into a structured form.
     * 
     * Currently, the following operations are performed:
     *  <ul>
     *    <li> Binding equations for variables are converted into regular
     *         equations by calling genBindingEquations().
     *    <li> For each non-function algorithm:
     *         <ul>
     *                any assigned variables as outputs and any used 
     *                variables as inputs.
     *           <li> The original algorithm is replaced with a call to 
     *                the generated function.
     *         </ul>
     *    <li> The model is scalarized, i.e., all array declarations and
     *         equations are replaced by scalar declarations and equations
     *    <li> Alias variables are eliminated from the model.
     *    <li> Derivative variables are generated and inserted in the
     *         list of FVariables by calling setFDerivativeVariables().
     *    <li> Generate initial equations based on start attribute.
     *    <li> Sort dependent parameters.
     *  </ul>
     */

    /**
     *  transformCanonicalBase contains all transformation that should be
     *  done by both the Modelica and the Optimica compilers.
     */
    public void FClass.transformCanonicalBase() {
        for (Transformation t : getTransformations()) {
            t.apply();
        }
    }

    public void FClass.transformCanonicalCleanup() {
        removeUnusedGlobals();
        root().flushAllRecursive();
    }
    
    public class FClass {
        
        /**
         * List that contains all transformations that has been registered.
         * This list is initialized by setupTransformations()
         */
        private java.util.List<Transformation> transformations;
        
        /**
         * Method that initializes the transformations list. This method should
         * called before each operation on the list. Internal check prevents
         * multiple initializations.
         */
        private void setupTransformations() {
            if (transformations != null)
                return;
            transformations = new ArrayList<Transformation>();
            transformations.add(new enableIfEquationElimination());
            transformations.add(new genAlgorithmFunctionsIfSet());
            transformations.add(new genInitArrayStatements());
            transformations.add(new scalarize());
            transformations.add(new MakeReinitedVarsStates());
            transformations.add(new enableIfEquationElimination());
            transformations.add(new enableStreamsRewrite());
            transformations.add(new ExtractEventGeneratingExpressions());
            transformations.add(new GenerateEventIndicators());
            transformations.add(new convertWhenToIf());
            transformations.add(new FunctionInliningIfSet());
            transformations.add(new setFDerivativeVariables());
            transformations.add(new addFPreVariables());
            transformations.add(new enableIfEquationRewrite());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new variabilityPropagationIfSet());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new eliminateLinearEquations());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new enableExpandedInStreamRewrite());
            transformations.add(new evaluateAsserts());
            transformations.add(new enableSemiLinearRewrite());
            transformations.add(new eliminateEqualSwitches());
            transformations.add(new genInitialEquations());
            transformations.add(new addStateInitialEquationsIfSet());
            transformations.add(new setFDerivativeVariablesPreBLT());
            transformations.add(new indexReduction());
            transformations.add(new LateFunctionInliningIfSet());
            transformations.add(new commonSubexpressionEliminationIfSet());
            transformations.add(new addFPreVariables());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new eliminateLinearEquations());
            transformations.add(new sortDependentParameters());
            transformations.add(new addRuntimeOptionParameters());
            transformations.add(new computeMatchingsAndBLT());
        }

        /**
         * This method returns the list of transformations. This method should
         * be used when retreiving the list of transformations since it ensures
         * that the list is initialized.
         */
        private Collection<Transformation> getTransformations() {
            setupTransformations();
            return transformations;
        }

        /**
         * Adds a transformation to the list of transformations. The
         * transformation is added after each occurance of <code>after<code>.
         * The transformation is not added if no occurances of 
         * <code>after<code> is found.
         */
        private <T extends Transformation> T addTransformationAfter(T transformation, String after) {
            setupTransformations();
            ListIterator<Transformation> it = transformations.listIterator();
            while (it.hasNext()) {
                Transformation other = it.next();
                if (other.name().equals(after))
                    it.add(transformation);
            }
            return transformation;
        }

        /**
         * Base class for transformations on the flat tree.
         */
        public abstract class Transformation {

            private String option;

            /**
             * Create a transformation with default settings:
             * <ul>
             * <li>Not coupled to a compiler option.</li>
             * </ul>
             */
            public Transformation() {
                this(null);
            }

            /**
             * Create a transformation with specific settings.
             * 
             * @param option  boolean option the transfomation depends on (null for none)
             */
            public Transformation(String option) {
                this.option = option;
            }

            /**
             * Perform the transformation.
             */
            public abstract void perform();

            /**
             * Determine if this transformation should be perfomed.
             * 
             * Defaults to true if this transformation does not depend on an option or the option is true.
             */
            public boolean active() {
                return (option == null) || myOptions().getBooleanOption(option);
            }

            /**
             * The name of this transformation.
             * 
             * Defaults to the name of the class.
             */
            public String name() {
                return getClass().getSimpleName();
            }

            /**
             * Apply this transformation, if active.
             * 
             * Subclasses should not override this method.
             */
            public void apply() {
                if (active()) {
                    try {
                        beginStep(name());
                        log.info("Applying transformation: " + name() + "...");
                        perform();
                    } finally {
                        completedTransformationSteps++;
                        lastCompletedTransformationStep = name();
                        endStep(name());
                    }
                    transformationStepDebug();
                }
            }

            /**
             * Flushes tree and discards calculated information.
             * 
             * Call this method at the end of perform() if it changed the tree.
             */
            void change() {
                setDAEBLT(BLT.EMPTY_BLT);
                setDAEInitBLT(BLT.EMPTY_BLT);
                DAEBiPGraph = null;
                root().flushAllRecursiveClearFinal();
            }
            
            @Override
            public String toString() {
                return getClass().getSimpleName() + ", operating on:\n\n" + FClass.this;
            }
        }

    }

    /**
     * Perform transformation step debug operations that are activated.
     */
    public void FClass.transformationStepDebug() {
        generateStepMof();
        sanityCheck();
    }

    /**
     * Generate a .mof file with the current flat tree.
     */
    public void FClass.generateStepMof() {
        String value = myOptions().getStringOption("debug_transformation_steps");
        if ("full".equals(value)) {
            TRANSFORMATION_STEP_DIR.mkdir();
            TRANSFORMATION_STEP_HTML_DIR.mkdir();
            String fileName = String.format("%02d_%s.mof", completedTransformationSteps, lastCompletedTransformationStep);
            String htmlFileName = String.format("%02d_%s.html", completedTransformationSteps, lastCompletedTransformationStep);
            File file = new File(TRANSFORMATION_STEP_DIR, fileName);
            File htmlFile = new File(TRANSFORMATION_STEP_HTML_DIR, htmlFileName);
            log.debug("Writing flat tree after step " + lastCompletedTransformationStep + " to " + fileName);
            try {
                CodeStream out = new CodeStream(file);
                CodeStream htmlOut = new CodeStream(htmlFile);
                sourcePrettyPrint(out, "");
                htmlSourcePrettyPrint(htmlOut, "");
                out.close();
                htmlOut.close();
            } catch (IOException e) {
                log.warning("Failed to write step info to file " + file);
            }
        }
        if ("full".equals(value) || "diag".equals(value)) {
            TRANSFORMATION_STEP_DIR.mkdir();
            String fileName = String.format("%02d_%s.txt", completedTransformationSteps, lastCompletedTransformationStep);
            File file = new File(TRANSFORMATION_STEP_DIR, fileName);
            log.debug("Writing diag after step " + lastCompletedTransformationStep + " to " + fileName);
            try {
                CodeStream out = new CodeStream(file);
                out.print(modelDiagnostics());
                out.close();
            } catch (IOException e) {
                log.warning("Failed to write step info to file " + file);
            }
        }
    }
    
    private static final File FClass.TRANSFORMATION_STEP_DIR = new File("transformation_steps");
    private static final File FClass.TRANSFORMATION_STEP_HTML_DIR = new File("transformation_steps_html");

    private int FClass.completedTransformationSteps = 0;
    private String FClass.lastCompletedTransformationStep = "flattening";

	/**
	 * After scalarization, binding expressions on members of record declarations are no longer needed. 
	 */
	public void FRecordDecl.clearBindingEquations() {
		for (FVariable fv : getFVariables())
		    if (fv.modifiableInRecord)
		        fv.setBindingExpOpt(new Opt());
	}

    protected boolean FClass.doneTransformCanonical = false;
    
    public void FClass.transformCanonical() {
        if (doneTransformCanonical)
            return;
        doneTransformCanonical = true;
        beginStep("transformCanonical()");

        transformCanonicalBase();
        

        root().flushAllRecursive();	
        transformCanonicalCleanup();
        getDAEBLT().errorCheck(this);
        getDAEInitBLT().errorCheck(this);

        endStep("transformCanonical()");
    }

    syn lazy Set<FVariable> FVariable.initDependsOn() {
        if (myDAEInitEquationBlock() != null)
            return myDAEInitEquationBlock().dependsOn();
        else
            return new LinkedHashSet<FVariable>();
    }

    syn lazy Set<FVariable> FVariable.dependsOn() {
        if (myDAEEquationBlock() != null)
            return myDAEEquationBlock().dependsOn();
        else
            return new LinkedHashSet<FVariable>();
    }

    syn lazy AbstractEquationBlock FVariable.myDAEEquationBlock() =
            myFClass().getDAEFVariableEquationBlockMap().get(this);

    private HashMap<FVariable, AbstractEquationBlock> FClass.daeFVariableEquationBlockMap =
            new HashMap<FVariable, AbstractEquationBlock>();

    syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEFVariableEquationBlockMap() {
        transformCanonical();
        return daeFVariableEquationBlockMap;
    }

    private HashMap<FAbstractEquation, AbstractEquationBlock> FClass.daeEquationEquationBlockMap =
            new HashMap<FAbstractEquation, AbstractEquationBlock>();

    syn HashMap<FAbstractEquation,AbstractEquationBlock> FClass.getDAEFEquationEquationBlockMap() {
        transformCanonical();
        return daeEquationEquationBlockMap;
    }

    syn lazy AbstractEquationBlock FVariable.myDAEInitEquationBlock() = 
            myFClass().getDAEInitFVariableEquationBlockMap().get(this);

    private HashMap<FVariable,AbstractEquationBlock> FClass.daeInitFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();
    syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEInitFVariableEquationBlockMap() {
        transformCanonical();
        return daeInitFVariableEquationBlockMap;
    }

    private HashMap<FAbstractEquation,AbstractEquationBlock> FClass.daeInitEquationEquationBlockMap = new HashMap<FAbstractEquation,AbstractEquationBlock>();
    syn HashMap<FAbstractEquation,AbstractEquationBlock> FClass.getDAEInitEquationEquationBlockMap() {
        transformCanonical();
        return daeInitEquationEquationBlockMap;
    }

    private ArrayList<FAbstractEquation> FClass.daeUnmatchedEquations = new ArrayList<FAbstractEquation>();
    syn ArrayList<FAbstractEquation> FClass.getDAEUnmatchedEquations() {
        transformCanonical();
        return daeUnmatchedEquations;
    }

    private ArrayList<FVariable> FClass.daeUnmatchedVariables = new ArrayList<FVariable>();
    syn ArrayList<FVariable> FClass.getDAEUnmatchedVariables() {
        transformCanonical();
        return daeUnmatchedVariables;
    }

    private ArrayList<FAbstractEquation> FClass.daeInitUnmatchedEquations = new ArrayList<FAbstractEquation>();
    syn ArrayList<FAbstractEquation> FClass.getDAEInitUnmatchedEquations() {
        transformCanonical();
        return daeInitUnmatchedEquations;
    }

    private ArrayList<FVariable> FClass.daeInitUnmatchedVariables = new ArrayList<FVariable>();
    syn ArrayList<FVariable> FClass.getDAEInitUnmatchedVariables() {
        transformCanonical();
        return daeInitUnmatchedVariables;
    }

    private BLT FClass.daeBLT = BLT.EMPTY_BLT;
    public BLT FClass.getDAEBLT() {
        transformCanonical();
        return daeBLT;
    }
    
    public void FClass.setDAEBLT(BLT newBLT) {
        daeBLT = newBLT;
        daeFVariableEquationBlockMap = new HashMap<FVariable, AbstractEquationBlock>();
        daeEquationEquationBlockMap = new HashMap<FAbstractEquation, AbstractEquationBlock>();

        for (AbstractEquationBlock eb : daeBLT) {
            for (FVariable fv : eb.allVariables()) {
                daeFVariableEquationBlockMap.put(fv,eb);
            }

            for (FAbstractEquation equation : eb.allEquations()) {
            	daeEquationEquationBlockMap.put(equation, eb);
            }
        }

        if (newBLT == BLT.EMPTY_BLT)
            daeStructuredBLT = BLT.EMPTY_BLT;
        else
            daeStructuredBLT = new StructuredBLT(this, daeBLT);
    }

    private StructuredBLT FClass.daeStructuredBLT = BLT.EMPTY_BLT;

    public StructuredBLT FClass.getDAEStructuredBLT() {
        transformCanonical();
        return daeStructuredBLT;
    }

    private BLT FClass.daeInitBLT = BLT.EMPTY_BLT;

    public BLT FClass.getDAEInitBLT() {
        transformCanonical();
        return daeInitBLT;
    }

    public void FClass.setDAEInitBLT(BLT newBLT) {
        daeInitBLT = newBLT;
        daeInitFVariableEquationBlockMap = new HashMap<FVariable, AbstractEquationBlock>();
        daeInitEquationEquationBlockMap = new HashMap<FAbstractEquation, AbstractEquationBlock>();

        for (AbstractEquationBlock eb : daeInitBLT) {
            for (FVariable fv : eb.allVariables()) {
                daeInitFVariableEquationBlockMap.put(fv,eb);
            }

            for (FAbstractEquation equation : eb.allEquations()) {
                daeInitEquationEquationBlockMap.put(equation, eb);
            }
        }
        daeInitBLT.computeDependencies();
    }

    syn boolean FClass.onlyInitBLT() = getDAEBLT() == BLT.EMPTY_BLT && getDAEInitBLT() != BLT.EMPTY_BLT;

    syn boolean FClass.shouldPerformMatchingsAndBLT() = true;

    public class FClass {
        /**
         * Run matchings and BLT.
         */
        public class computeMatchingsAndBLT extends Transformation {
            public computeMatchingsAndBLT() {
                super("automatic_add_initial_equations");
            }

            @Override
            public boolean active() {
                return super.active() && shouldPerformMatchingsAndBLT();
            }

            @Override
            public void perform() {
                computeMatchingsAndBLT();
                complianceCheckBLT();
                breakOnErrors();
            }
        }
    }
    
    public void FClass.complianceCheckBLT() {
        getDAEBLT().complianceCheck(ErrorCheckType.COMPILE, myOptions());
        getDAEInitBLT().complianceCheck(ErrorCheckType.COMPILE, myOptions());
    }
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_NORMAL = 
            EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
                    BiPGraph.VarType.ALGEBRAIC_VARIABLES);
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_REAL = 
            EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
                    BiPGraph.VarType.CONTINUOUS_ALGEBRAIC_VARIABLES);
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_INIT = 
            EnumSet.of(BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
                    BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
                    BiPGraph.VarType.NON_FIXED_PARAMETERS);
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_ALL = 
            EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
                    BiPGraph.VarType.ALGEBRAIC_VARIABLES, 
                    BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
                    BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
                    BiPGraph.VarType.NON_FIXED_PARAMETERS);
    
    private BiPGraph FClass.computeMatchedDAEBiPGraph() {
        BiPGraph g = new BiPGraph();
        g.addVariables(this, VAR_TYPES_NORMAL);
        g.addEquations(equations(), VAR_TYPES_NORMAL);
        g.maximumMatching(true);
        daeUnmatchedVariables.clear();
        for (Var var : g.getUnmatchedVariables())
            daeUnmatchedVariables.add(var.getVariable());
        daeUnmatchedEquations.clear();
        for (Eq ee : g.getUnmatchedEquations())
            daeUnmatchedEquations.add(ee.getEquation());
        return g;
    }
    
    private BiPGraph FClass.DAEBiPGraph = null;
    
    /**
     * The symbolic equation sorting and canonicalization proceeds in the
     * following steps:
     * 
     * - The DAE system consisting of the DAE equations with algebraics and
     *   derivatives treated as unknowns is matched to obtain a pairing
     *   between equations and variables. Discrete and continuous algebraic
     *   variables are treated equally in this respect.
     *
     * - If a perfect matching is found, i.e., if there are no unmatched
     *   equations or variables, the BLT algoritm is applied to compute
     *   a sequence of stron components, corresponding to systems of equations.
     * 
     * - Having computed a matching and transformed the DAE into BLT form, 
     *   the DAE initialization system is analyzed:
     *    - The differentiated variables are added to the set of unknown 
     *      variables of the system.
     *    - The pre variables are added to the set of unknown variables of the
     *      system.
     *    - The initial equations are added to the set of equations of the 
     *      system. This includes equations resulting from start values with
     *      a corresonding fixed attribute set to true.
     *    - When clauses are analyzed: if a when clause is explicitly enabled by
     *      the initial() operator (whatever this means...), the when clause 
     *      is excluded, otherwhise the equation pre(x) = x is added, where x 
     *      is the variable that is solved for in the when clause.
     *      
     * - The matching algoritm is applied to the updated graph. Notice that it
     *   is important that the result of the DAE matching is used as a starting
     *   point: using this approach, derivatives and algebraics will remain
     *   matched if possible and additional equations are added, if needed,
     *   for differentiated variables. If there are 
     *   unmatched equations, the transformation sequence terminates. If there
     *   are unmatched variables, then additional initial equations are added 
     *   in order to obtained a balanced system. For continuous variables, 
     *   equations such as x = x.start are added, whereas for discrete variables
     *   equations such as pre(x) = x.start are added.
     *
     *  - Finally, the BLT algorithm is applied to the resulting perfect
     *    matchibng for the DAE initialization system.
     */
    private void FClass.computeMatchingsAndBLT() {
        // Make sure that we don't do this if any errors have been reported
        breakOnErrors();

        log.verbose("Flat tree before matching and BLT:");
        log.verbose(this);

        BiPGraph g;
        if (DAEBiPGraph == null) {
            g = computeMatchedDAEBiPGraph();
            log.verbose("DAE BiPGraph");
            log.verbose(g);
            log.verbose("DAE BiPGraph matching");
            log.verbose(g.printMatchingObj());
        } else {
            g = DAEBiPGraph;
            DAEBiPGraph = null;
        }
		
        log.verbose(g);
        
        // If no complete matching found, then fail
        if (!g.isComplete()) {
            checkStructure();
            breakOnErrors();
        } 

        // Perform BLT
        if (myOptions().getBooleanOption("equation_sorting") &&
                !myOptions().getBooleanOption("generate_only_initial_system") &&
                g.isComplete()) {
            BLT daeBLT;
            try {
                daeBLT = g.computeDAEBLT(myOptions());
                if (blockFunctionExtraction(daeBLT, g)) {
                    daeBLT = g.computeDAEBLT(myOptions());
                }
            } catch (BLTException e) {
                error(e.getMessage());
                return;
            }
            setDAEBLT(daeBLT);
            log.verbose(getDAEStructuredBLT());
            log.verbose(getDAEBLT());
        } else {
            setDAEBLT(BLT.EMPTY_BLT);
        }
        
        g.removeVariables(dynamicAlgebraicVariables());
        
        // Find matching for the initialization system
        g.addVariables(this, VAR_TYPES_INIT);
        g.addEquations(equations(), VAR_TYPES_INIT);
        g.setAsInitialSystem();
        
        // Replace when equations
        java.util.List<FAbstractEquation> equationsToReplace = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : equations()) {
            if (e.replacedAtInitialization()) {
                equationsToReplace.add(e);
            }
        }
        
        Set<FAbstractVariable> existingPrePropagationLikeInitialEquations = new HashSet<FAbstractVariable>();
        for (FAbstractEquation eqn : initialEquations()) {
            FAbstractVariable var = eqn.isPrePropagationEquation();
            if (var != null)
                existingPrePropagationLikeInitialEquations.add(var);
        }
        
        Map<FAbstractVariable, FAbstractEquation> prePropagationEquations = new HashMap<FAbstractVariable, FAbstractEquation>();
        // Loop over all equations to replace
        for (FAbstractEquation equationToReplace : equationsToReplace) {
            
            // How many equations are there in this when clause?
            List<FAbstractEquation> newEquations = equationToReplace.getInitialEquations();
            
            // Put the Equations in an ArrayList rather than a List
            // TODO: There are probably more elegant ways to do this...
            java.util.List<FAbstractEquation> newEquations_ = new ArrayList<FAbstractEquation>();
            for (FAbstractEquation e : newEquations) {
                FAbstractVariable var = e.isPrePropagationEquation();
                if (var == null) {
                    newEquations_.add(e);
                } else {
                    if (existingPrePropagationLikeInitialEquations.contains(var))
                        continue;
                    boolean hasOthers = false;
                    boolean assignedInAllBranches = false;
                    for (FAccessExp exp : var.uses()) {
                        FAbstractEquation eqn = exp.myFEquation();
                        if (eqn == null || eqn == e || eqn == equationToReplace || !(eqn.inEquationSection() || eqn.inInitialEquationSection()))
                            continue;
                        hasOthers = true;
                        if (eqn.assignedInAllBranches(var))
                            assignedInAllBranches = true;
                    }
                    
                    if (!hasOthers || assignedInAllBranches)
                        prePropagationEquations.put(var, e);
                    else
                        newEquations_.add(e);
                }
            }
            
            // - equationToReplace is an FAbstractEquation that should be replaced
            // - newEquations contains the new equations that replaces the equationToReplace
            // - Note that newEquations may contain several equations
            
            java.util.List<Eq> eq_list = new ArrayList<Eq>(g.getEquations(equationToReplace));
            
            for (Eq eqq : eq_list) {
                g.removeEquation(eqq);
            }
            
            if (!eq_list.isEmpty())
                g.addEquations(newEquations_, VAR_TYPES_ALL, eq_list.get(0).getName() + "_init_", new Enumerator(1));
        }
        
        log.verbose(g);
        
        g.addEquations(initialEquations(), VAR_TYPES_ALL);
        
        g.maximumMatching(false, prePropagationEquations.keySet());
        log.verbose("Init DAE BiPGraph");
        log.verbose(g);
        log.verbose("Init BiPGraph matching");
        log.verbose(g.printMatchingObj());
        
        g = overdeterminedInitialSystem(g);
        
        // Add initial equations if needed
        if (g.getUnmatchedEquations().isEmpty() && myOptions().getBooleanOption("automatic_add_initial_equations")) {
            for (Var var : g.getUnmatchedVariables()) {
                FVariable fv = var.getVariable();
                FAbstractEquation fe = prePropagationEquations.remove(fv);
                if (fe == null && fv.isPreVariable())
                    fe = prePropagationEquations.remove(fv.myNonPreVariable());
                if (fe == null) {
                    FAccessExp lhs = fv.isPreVariable() ? fv.createFPreExp() : fv.createAccessExp();
                    FExp rhs = fv.startAttributeSet() ? fv.startAttributeExp() : fv.type().zeroLiteral();
                    fe = new FEquation(lhs, rhs);
                    fe.setLocationNoTree(fv);
                    addFInitialEquation(fe);
                }
                g.addEquations(Collections.singletonList(fe), VAR_TYPES_ALL);
            }
            root().flushAllRecursive();
            
            g.maximumMatching(false);
            log.verbose("Init DAE BiPGraph after addition of initial equations");
            log.verbose(g);
            log.verbose("Init BiPGraph matching after addition of initial equations");
            log.verbose(g.printMatchingObj());
        }
        
        numIgnoredPrePropagationEquations = prePropagationEquations.size() 
                + existingPrePropagationLikeInitialEquations.size();
        
        for (Var var : g.getUnmatchedVariables()) {
            daeInitUnmatchedVariables.add(var.getVariable());
        }
        
        for (Eq ee : g.getUnmatchedEquations()) {
            daeInitUnmatchedEquations.add(ee.getEquation());
        }
        
        collectErrors(ErrorCheckType.COMPILE);
        breakOnErrors();
        
        if (myOptions().getBooleanOption("equation_sorting") && g.isComplete()) {
            g.tarjanReset();
            BLT daeInitBLT;
            try {
                daeInitBLT = g.computeInitDAEBLT(myOptions());
                if (blockFunctionExtraction(daeInitBLT, g)) {
                    daeInitBLT = g.computeInitDAEBLT(myOptions());
                }
            } catch (BLTException e) {
                error(e.getMessage());
                return;
            }
            setDAEInitBLT(daeInitBLT);
            log.verbose(daeInitBLT);
        } else {
            setDAEInitBLT(BLT.EMPTY_BLT);
        }
    }
    
    syn FAbstractVariable FAbstractEquation.isPrePropagationEquation() = null;
    eq FEquation.isPrePropagationEquation() {
        FAbstractVariable left = getLeft().isAccess() ? getLeft().asCommonAccess().asFAccess().myFV() : null;
        FAbstractVariable right = getRight().isAccess() ? getRight().asCommonAccess().asFAccess().myFV() : null;
        return left == right ? left : null;
    }
    
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	public void FClass.checkStructure() {
		if (myOptions().getBooleanOption("enable_structural_diagnosis")) {
			StringBuffer err_str = new StringBuffer("The system is structurally singular. ");
			if (writeUnmatchedElements(err_str, getDAEUnmatchedVariables(), getDAEUnmatchedEquations())) 
				error(err_str.toString());
			err_str = new StringBuffer("The initialization system is structurally singular. ");
			if (writeUnmatchedElements(err_str, getDAEInitUnmatchedVariables(), getDAEInitUnmatchedEquations())) 
				error(err_str.toString());
		}
	}
	
	public static boolean FClass.writeUnmatchedElements(StringBuffer str, Collection<FVariable> unmatchedVariables, Collection<FAbstractEquation> unmatchedEquations) {
		boolean unbalanced = false;
		if (!unmatchedVariables.isEmpty()) {
			str.append("The following varible(s) could not be matched to any equation:\n");
			for (FVariable fv : unmatchedVariables) {
				str.append("     " + fv.name());
				str.append("\n");
			}
			unbalanced = true;
		}
		
		if (!unmatchedEquations.isEmpty()) {
			if (unbalanced) 
				str.append("\n  ");
			str.append("The following equation(s) could not be matched to any variable:\n");
			for (FAbstractEquation ee : unmatchedEquations) {
				str.append(ee.prettyPrint("    "));
				str.append("\n");
			}
			unbalanced = true;
		}
		return unbalanced;
	}
	
    public class FClass {
        public class genAlgorithmFunctionsIfSet extends Transformation {
            public genAlgorithmFunctionsIfSet() {
                super("algorithms_as_functions");
            }
            
            public void perform() {
                genAlgorithmFunctions();
            }
        }
    }
	
	/**
	 * Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		for (FAlgorithm alg : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FAccess funcName = new FAccessString(alg.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FAccessExp use : alg.FAccessExpsInRHS()) {
				FAbstractVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FAccessExp use : alg.FAccessExpsInLHS()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
            List<FStatement> stmts = new List<FStatement>();
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
                    ffv.setFAccess(new FAccessString(name));
					
					// Create and add binding expression for output
                    stmts.add(new FAssignStmt(bothInVars.get(i).createAccessExp(), ffv.createAccessExp()));
				}
			}
			
            for (FStatement stmt : alg.getFStatements()) {
                stmts.add(stmt);
            }
            alg.setFStatementList(stmts);
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
            FType type = FFunctionType.create(funcName.name(), outVars, this);
            FFunctionCall call = new FFunctionCall(funcName, args, type);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFAccess().createFFunctionCallLeft());
			replaceEquation(alg, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			alg.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, alg, new List<FAttribute>()));
		}
	}

	/**
	 * Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		getFAbstractEquations().replaceChild(oldEq, newEq);
	}
	
	/**
	 * Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FAccess.createFFunctionCallLeft() {
		FAccess access = fullCopy();
		access.removeFArraySubscripts();
		return new FFunctionCallLeft(new Opt(new FAccessExp(access)));
	}

	/**
	 * Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return createFPreExp();
			if (isContinuous())
				return createStartAttributeExp();
		}
		return createAccessExp();
	}
	
	/**
	 * Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(TypePrefixInputOutput.OUTPUT);
	}

	/**
	 * Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(TypePrefixInputOutput.INPUT);
	}

	/**
	 * Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(TypePrefixInputOutput io) {
		FType type = (FType) type().fullCopy();
		return new FFunctionVariable(io, type, new Opt(), getFAccess().fullCopy());
	}

    public static final SimpleProblemProducer ASTNode.DIFFERENTIATED_DISCRETE_VARIABLE =
            new SimpleErrorProducer("DIFFERENTIATED_DISCRETE_VARIABLE", ProblemKind.SEMANTIC,
                    "Unable to differentiate the variable %s which is declared or infered to be discrete");
	
    public class FClass {
        
        public setFDerivativeVariables setFDerivativeVariables = new setFDerivativeVariables();
        
        /**
         * Remake all FDerivativeVariables.
         */
        public class setFDerivativeVariables extends Transformation {
            protected Set<FVariable> variablesToVisit() {
                return new LinkedHashSet<FVariable>(differentiatedRealVariablesFilteredSet());
            }
            
            public void perform() {
                ArrayList<FVariable> l = new ArrayList<FVariable>();
                for (FVariable fv : getFVariables()) {
                    if (!fv.isDerivativeVariable()) {
                        l.add(fv);
                    }
                }
                for (FVariable fv : variablesToVisit()) {
                    if (fv.isDiscrete()) {
                        DIFFERENTIATED_DISCRETE_VARIABLE.invoke(fv, fv.name());
                    }
                    l.add(fv.createFDerivativeVariable());
                }
                setFVariableList(new List<FVariable>(l));
                root().flushAllRecursive();
                breakOnErrors();
            }
        }
        
        /**
         * Used by index reduction when removing derivatives of state select
         * prefer variables.
         */
        private Set<FVariable> ssPreferVars = null;
        
        /**
         * Add derivative variables to the list of FVariables.
         * Derivative variable is added for a variable of either of the following is true:
         *  - Occurres differentiated
         *  - Have StateSelect always or prefer
         */
        public class setFDerivativeVariablesPreBLT extends setFDerivativeVariables {
            @Override
            protected Set<FVariable> variablesToVisit() {
                ssPreferVars = new HashSet<FVariable>();
                Set<FVariable> fvsToVisit = super.variablesToVisit();
                boolean indexReductionActive = myOptions().getBooleanOption("index_reduction");
                for (FVariable fv : variables()) {
                    if (!fv.isReal()) {
                        continue;
                    }
                    FRealVariable.StateSelect ss = ((FRealVariable)fv).stateSelectAttribute();
                    if (!(ss == FRealVariable.StateSelect.ALWAYS
                            || ss == FRealVariable.StateSelect.PREFER && indexReductionActive)) {
                        continue;
                    }
                    if (ss == FRealVariable.StateSelect.PREFER && !fvsToVisit.contains(fv)) {
                        ssPreferVars.add(fv);
                    }
                    fvsToVisit.add(fv);
                }
                return fvsToVisit;
            }
        }
    }

    public void FClass.addFDerivativeVariables(Collection<FVariable> fvs) {
        for (FVariable fv : fvs)
            addFVariable(fv);
        root().flushAllRecursive();
    }

	public FAbstractDerivativeVariable FVariable.createFDerivativeVariable() {
	    throw new UnsupportedOperationException("Trying to create a derivative variable from the non real variable " + name() + "! Java class type: '" + getClass().getSimpleName() + "'");
	}

    @Override
    public FAbstractDerivativeVariable FRealVariable.createFDerivativeVariable() {
        FAbstractDerivativeVariable fdv;
        if (isDynamicState()) {
            FDynamicDerivativeVariable var = new FDynamicDerivativeVariable();
            var.setSet(dynamicStateSet());
            fdv = var;
        } else {
            fdv = new FDerivativeVariable();
        }
        fdv.setVisibilityType(getVisibilityType());
        fdv.setTypePrefixVariability(getTypePrefixVariability());
        fdv.setTypePrefixInputOutput(TypePrefixInputOutput.NONE);
        fdv.setFAccess(getFAccess().fullCopy());
        fdv.setOrder(order() + 1);
        fdv.setMeIntegrated(this);
        this.setMeDifferentiated(fdv);
        fdv = dynamicVariable(fdv);
        FAttribute ssAttr = findAttributeLocal(FAttribute.STATE_SELECT);
        if (ssAttr != null) {
            StateSelect ss = stateSelectAttribute();
            if (ss == StateSelect.NEVER || ss == StateSelect.AVOID)
                fdv.addFAttribute(ssAttr.fullCopy());
        }
        return fdv;
    }

    public class FClass {
        /**
         * Add pre variables to the list of FVariables, one for each
         * discrete variable and one for each continuous variable that is 
         * used in a pre() expression in an initial equation.
         */
        public class addFPreVariables extends Transformation {
            public void perform() {
                ArrayList<FVariable> l = new ArrayList<FVariable>();
                for (FVariable fv : discreteVariables()) 
                    if (fv.myPreVariable().isUnknown())
                        l.add(fv.createPreVariable());
                for (FVariable fv : continuousVariablesUsedInPreInInitial())
                    if (fv.myPreVariable().isUnknown())
                        l.add(fv.createPreVariable());
                for (FVariable fv : l) 
                    addFVariableNoTransform(fv);
                root().flushAllRecursive();
            }
        }
    }
    
    syn lazy Collection<FVariable> FClass.continuousVariablesUsedInPreInInitial() {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        getFInitialEquations().gatherContinuousVariablesUsedInPre(res);
        return new ArrayList<FVariable>(res);
    }
    
    public void ASTNode.gatherContinuousVariablesUsedInPre(Set<FVariable> res) {
        for (ASTNode n : this) 
            n.gatherContinuousVariablesUsedInPre(res);
    }
    
    public void FPreExp.gatherContinuousVariablesUsedInPre(Set<FVariable> res) {
        FAbstractVariable fv = getFAccess().myFV();
        if (fv.isContinuous())
            res.add((FVariable) fv);
    }
    
	
	/**
	 * Create a pre variable for this variable.
	 */
	abstract public FVariable FVariable.createPreVariable();

    public FVariable FGlobalVariable.createPreVariable() {
        throw new UnsupportedOperationException();
    }

	public FVariable FRealVariable.createPreVariable() {
		return new FPreRealVariable(this);
	}
	
	public FVariable FIntegerVariable.createPreVariable() {
		return new FPreIntegerVariable(this);
	}
	
	public FVariable FEnumVariable.createPreVariable() {
		return new FPreEnumVariable(this);
	}
	
	public FVariable FBooleanVariable.createPreVariable() {
		return new FPreBooleanVariable(this);
	}
	
	public FVariable FStringVariable.createPreVariable() {
		return new FPreStringVariable(this);
	}
	
	public FVariable FRecordVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}
	
	public FVariable FExternalObjectVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}


    public class FClass {
        /**
         * Generate initial equations from variables with fixed start
         * attributes.
         * 
         * Intitial equations corresponding to explicitly set start attributes of 
         * differentiated variables are also generated, without taking the fixed
         * attribute into account.
         */
        public class genInitialEquations extends Transformation {
            public void perform() {
                // TODO: Isn't there always a value for fv.startAttributeExp() now?
                for (FVariable fv : variables()) {
                    boolean generate = false;
                    if (!myOptions().getBooleanOption("state_initial_equations") &&
                            fv.isDifferentiatedVariable() && (fv.isFixed() ||
                            myOptions().getBooleanOption("state_start_values_fixed")))
                        generate = true;
                    else if (!myOptions().getBooleanOption("state_initial_equations") &&
                            fv.isAlgebraicContinousRealVariable() && fv.isFixed())
                        generate = true;
                    else if (fv.isDiscrete() && fv.isFixed()) {
                        generate = true;
                    }
                    
                    if (generate) {
                        FExp lhs = fv.setLocationOf(fv.isDiscrete() ? fv.createFPreExp() : fv.createAccessExp());
                        FExp rhs = fv.setLocationOf(fv.startAttributeSet() ? fv.startAttributeExp().fullCopy() : fv.type().zeroLiteral());
                        addFInitialEquation(new FEquation(lhs, rhs));
                    }
                }
                root().flushAllRecursive();
            }
        }
    }
}

aspect DummyDerivatives {

    rewrite FDerExp {
        when (myFV().isDummyDerivativeVariable()) to FDummyDerExp {
            return new FDummyDerExp(getFAccess(), getOriginalVariable(), order());
        }
    }

    public void ASTNode.enableFHDerRewrite() {
        for (ASTNode n : this)
            n.enableFHDerRewrite();
    }

    public void FDerExp.enableFHDerRewrite() {
        rewriteFHDer = true;
        is$Final = false;
    }

    boolean FDerExp.rewriteFHDer = false;

    public void FDerivativeVariable.enableFHDerRewrite() {
        rewriteFHDer = true;
        is$Final = false;
    }

    boolean FDerivativeVariable.rewriteFHDer = false;

    rewrite FDerExp {
        when (rewriteFHDer && order() > 1) to FDerExp 
        new FDerExp(getFAccess().createDerPrefixedName(order() - 1));
    }

}

aspect TransformCanonicalErrorCheck {
	
	/**
	 * The number of DAE equations corresponds to the equivalent scalar number
	 * of equations.
	 */
	syn int FClass.numDAEEquations() = numScalarEquations();
	
	/**
	 * The number of equations in the DAE initialization system originating 
	 * from the DAE should be the same as the equivalent scalar number of
	 * equations. The equations may differ, however, due to inactive when
	 * clauses.
	 */
	syn int FClass.numDAEEquationsAtInitialization() 
		= numScalarEquationsAtInitialization();
	
	/**
	 * The number of unknown variables in the DAE corresponds to the number
	 * of real algebraic variables plus the number of derivative variables
	 * plus the number of discrete variables.
	 */
	syn int FClass.numDAEVariables() = 
        numNormalAlgebraicContinousRealVariables() + 
		numDerivativeVariables() + numDiscreteVariables();
	
    /**
     * This field is populated by computeMatchingsAndBLT, there are some models
     * where the initial system is defined so that pre propgation equations
     * such as x = pre(x) can't be inserted. These equations are then ignored
     * which must be accounted for during balance computations.
     */
    private int FClass.numIgnoredPrePropagationEquations = 0;

	/**
	 * The number of equations in the DAE initialization system is the 
	 * number of scalar DAE equations plus the number of scalar initial
	 * equations.
	 */	
	syn int FClass.numDAEInitEquations() = numDAEEquationsAtInitialization() + 
        numInitialScalarEquations() - numIgnoredPrePropagationEquations;
	
	/**
	 * The number of unknowns in the DAE initialization system is the 
	 * number of unknowns in the DAE system plus the number of differentiated
        * variables plus the number of (pre) discrete variables.
        */
       syn int FClass.numDAEInitVariables() = numDAEVariables() +
               numDifferentiatedRealVariables() + numDiscretePreVariables() +
               numInitialParameters() + numDynamicStates() - numDynamicAlgebraicVariables();

       public void FClass.checkFClassDimensions() {
               // Check dimensions of DAE
		int n_eq_F = numDAEEquations();
		int n_vars_F = numDAEVariables();
		if (n_eq_F != n_vars_F) 
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numDAEInitEquations();
		int n_vars_F0 = numDAEInitVariables();
		if (n_eq_F0 > n_vars_F0) 
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		
	}
	
	public void FClass.collectErrors(ErrorCheckType checkType) {
		checkFClassDimensions();
		checkStructure();
		allChecks(checkType);
	}
}

aspect FlushFClass {
	/**
	 * Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FExps in order to enable rewrites of such nodes after elimination 
	 * of alias variables and after function inlining.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}
	
	public void FExp.flushAllRecursiveClearFinal() {
		super.flushAllRecursiveClearFinal();
		is$Final = false;
	}

	/**
	 * Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (ASTNode n : noTransform()) {
			n.flushAllRecursive();
		}
	}
	
	/**
	 * Flush model AST and enable rewrites of FAccessExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
	/**
	 * Traverse entire tree, forcing any pending rewrites to occur.
	 */
	public void ASTNode.forceRewrites() {
        for (ASTNode n : this) 
            n.forceRewrites();
	}
	
}



aspect Tearing {
	
	
}


aspect StateInitialEquations {

    public class FClass {
        public class addStateInitialEquationsIfSet extends Transformation {
            // Constraints: after alias elimination (see #), before BLT
            
            public addStateInitialEquationsIfSet() {
                super("state_initial_equations");
            }
            
            public void perform() {
                addStateInitialEquations();
            }
        }
    }

    public void FClass.addStateInitialEquations() {
        setFInitialEquationList(new List());
        
        for (FVariable fv : differentiatedRealVariables()) {
            FAccess nameToAdd = fv.getFAccess().copyAndAddPrefix("_start_");
            FRealVariable fvToAdd = new FRealVariable(VisibilityType.PUBLIC, Variability.FIXEDPARAMETER, nameToAdd);
            if (fv.startAttributeSet())
                fvToAdd.setBindingExp(fv.startAttributeExp().ceval().buildLiteral());
            else
                fvToAdd.setBindingExp(fv.type().zeroLiteral());
            addFVariable(fvToAdd);
            FEquation eqnToAdd = new FEquation(fv.createAccessExp(), fvToAdd.createAccessExp());
            addFInitialEquation(eqnToAdd);
            flushAllRecursive();
        }
    }

}

aspect SemiLinear {

    public class FClass {
        public class enableSemiLinearRewrite extends Transformation {
            private boolean changed = false;
            
            public void perform() {
                setFAbstractEquationList(transform(getFAbstractEquations()));
                setFInitialEquationList(transform(getFInitialEquations()));
                setParameterEquationList(transform(getParameterEquations()));
                
                // Change all remaining semiLinear exps to if exps.
                Set<FSemiLinearExp> fsls = collectSemiLinearExps();
                changed = changed || fsls.size() > 0;
                for (FSemiLinearExp exp: fsls)
                    exp.replaceMe(exp.asIfExp());
                
                if (changed) {
                    change();
                }
            }
            
            /**
             * Applies zero flow transformations to a list of equations.
             */
            private List<FAbstractEquation> transform(List<FAbstractEquation> equations) {
                ListMap<String, FEquation> rule1 = new LinkedHashListMap<String, FEquation>();
                ArrayList<FEquation> rule2 = new ArrayList<FEquation>();
                List<FAbstractEquation> newEquations = new List<FAbstractEquation>();
                
                // Find zero flow equations
                for (FAbstractEquation equation : equations) {
                    if (equation.isConstantZeroFlow()) {
                        rule2.add((FEquation) equation);
                    } else if (equation.isZeroFlowForm()) {
                        FEquation e = (FEquation) equation;
                        rule1.add(e.zeroFlowGetKey(), e);
                    }
                }
                
                // Chained zero flow transformations (Rule 1)
                for (java.util.List<FEquation> l : rule1.values()) {
                    if (l.size() > 1) {
                        transformChain(newEquations, buildChain(l));
                        changed = true;
                    }
                }
                
                changed = changed || rule2.size() > 0;
                
                // Constant zero flow transformations (Rule 2)
                for (FEquation equation : rule2) {
                    equation.setLeft(equation.zeroFlowGetPos());
                    equation.setRight(equation.zeroFlowGetNeg());
                }
                
                List<FAbstractEquation> res = removeMarkedEqns(equations);
                res.addAll(newEquations);
                return res;
            }
            
            /**
             * Order the equations in <code>l</code> by matching the slopes in
             * the semiLinear expressions. If any equation cannot be ordered an
             * error is given.
             */
            private ArrayList<FEquation> buildChain(java.util.List<FEquation> l) {
                ArrayList<FEquation> chain = new ArrayList<FEquation>();
                FEquation eq1 = l.remove(0);
                chain.add(eq1);
                
                boolean change = true;
                while (change) {
                    change = false;
                    Iterator<FEquation> it = l.iterator();
                    while (it.hasNext()) {
                        FEquation eq2 = it.next();
                        if (addToChain(chain, eq2)) {
                            change = true;
                            it.remove();
                        }
                    }
                }
                
                if (l.size() > 0) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Could not construct zero flow chain for a set of semilinear equations."
                            + " This leads to an undetermined system. Involved equations:\n");
                    
                    for (FEquation e : chain) {
                        sb.append(e.prettyPrint(""));
                        sb.append("\n");
                    }
                    for (FEquation e : l) {
                        sb.append(e.prettyPrint(""));
                        sb.append("\n");
                    }
                    
                    l.get(0).error(sb.toString());
                }
                return chain;
            }
            
            /**
             * Add an equation to the chain if the slopes match
             */
            private boolean addToChain(ArrayList<FEquation> chain, FEquation equation) {
                FExp pos = equation.zeroFlowGetPos();
                FExp neg = equation.zeroFlowGetNeg();
                FExp chainNeg = chain.get(chain.size()-1).zeroFlowGetNeg();
                FExp chainPos = chain.get(0).zeroFlowGetPos();
                
                if (chainNeg.prettyPrint("").equals(pos.prettyPrint(""))) {
                    chain.add(equation);
                    return true;
                } else if (chainPos.prettyPrint("").equals(neg.prettyPrint(""))) {
                    chain.add(0, equation);
                    return true;
                }
                return false;
            }
            
            /**
             * Build new equations to represent the chain of semiLinears
             */
            private void transformChain(List<FAbstractEquation> newEquations, ArrayList<FEquation> chain) {
                for (FEquation e : chain)
                    e.markedForRemoval = true;
                
                FEquation first = chain.get(0);
                FEquation last  = chain.remove(chain.size()-1);
                FExp chainPos   = first.zeroFlowGetPos();
                FExp chainNeg   = last.zeroFlowGetNeg();
                FExp chainX     = first.zeroFlowGetX();
                
                // S(1) = if X >= 0 SA else SB
                newEquations.add(new FEquation(
                        first.zeroFlowGetNeg().fullCopy(), 
                        new FIfExp(new FGeqExp(chainX.fullCopy(), new FIntegerLitExp(0)),
                                chainPos.fullCopy(),
                                chainNeg.fullCopy()
                                )));
                
                // S(n+1) = S(n)
                FEquation pre_e = null;
                for (FEquation e : chain) {
                    if (pre_e != null)
                        newEquations.add(new FEquation(e.zeroFlowGetNeg().fullCopy(), pre_e.zeroFlowGetNeg().fullCopy()));
                    pre_e = e;
                }
                
                // Y = semiLinear(X,SA,SB)
                FExp slExp = new FSemiLinearExp(chainX.fullCopy(), chainPos.fullCopy(), chainNeg.fullCopy());
                newEquations.add(new FEquation(
                        first.zeroFlowGetLeft().fullCopy(),
                        slExp.negated(first.zeroFlowNegated())
                        ));
            }
        }
    }
    
    syn boolean FAbstractEquation.isZeroFlowForm() = false;
    eq FEquation.isZeroFlowForm() { 
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return l.isZeroFlowForm(r) || r.isZeroFlowForm(l);
    }
    
    syn boolean FExp.isZeroFlowForm(FExp other) = false;
    eq FAccessExp.isZeroFlowForm(FExp other) = other.isSemiLinear(); 
    
    syn boolean FAbstractEquation.isConstantZeroFlow() = false;
    eq FEquation.isConstantZeroFlow() { 
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        
        if (l.isZeroLiteral() && r.isSemiLinear()) {
            return ((FSemiLinearExp) r).getX().isZeroLiteral();
        }
        if (r.isZeroLiteral() && l.isSemiLinear()) {
            return ((FSemiLinearExp) l).getX().isZeroLiteral();
        }
        
        return false;
    }
    
    syn FAccessExp FEquation.zeroFlowGetLeft() {
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return (l.isSemiLinear() ? r : l).asFAccessExp();
    } 
    
    syn FSemiLinearExp FEquation.zeroFlowGetRight() {
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return (FSemiLinearExp) (l.isSemiLinear() ? l : r);
    } 
    syn FExp FEquation.zeroFlowGetX()     = zeroFlowGetRight().getX().stripNegations();
    syn FExp FEquation.zeroFlowGetPos()   = zeroFlowGetRight().getX().isNegated() ? zeroFlowGetRight().getNegSlope() : zeroFlowGetRight().getPosSlope();
    syn FExp FEquation.zeroFlowGetNeg()   = zeroFlowGetRight().getX().isNegated() ? zeroFlowGetRight().getPosSlope() : zeroFlowGetRight().getNegSlope();
    
    syn boolean FEquation.zeroFlowNegated() = isNegated() ^ zeroFlowGetRight().getX().isNegated();
    
    syn String FEquation.zeroFlowGetKey() {
        StringBuilder sb = new StringBuilder();
        if (zeroFlowNegated())
            sb.append("-");
        sb.append(zeroFlowGetLeft().prettyPrint(""));
        sb.append("$");
        sb.append(zeroFlowGetX().prettyPrint(""));
        return sb.toString();
    }
    
	
	syn boolean FExp.isSemiLinear() = false;
	eq FSemiLinearExp.isSemiLinear() = true;

    syn FExp FSemiLinearExp.asIfExp() {
        FExp exp = new FIfExp(new FGeqExp(getX().treeCopy(), new FIntegerLitExp(0)),
            new FMulExp(getX().treeCopy(), getPosSlope().treeCopy()),
            new FMulExp(getX().treeCopy(), getNegSlope().treeCopy()));
        if (isSmoothInSemiLinear()) {
            exp = new FNoEventExp(exp);
        }
        return exp;
    }

    /**
     * Checks if this expression allows a semiLinear() with it as argument to be smooth(0, ...).
     */
    syn boolean FExp.isSmoothInSemiLinear()  = false;
    eq FAccessExp.isSmoothInSemiLinear()      = true;
    eq FLitExp.isSmoothInSemiLinear()        = true;
    eq FSmoothExp.isSmoothInSemiLinear()     = true;
    eq FNegExp.isSmoothInSemiLinear()        = getFExp().isSmoothInSemiLinear();
    eq FSemiLinearExp.isSmoothInSemiLinear() = 
        getX().isSmoothInSemiLinear() && getPosSlope().isSmoothInSemiLinear() && getNegSlope().isSmoothInSemiLinear();

	/**
	 * Collects semiLinear expressions.
	 */
	coll HashSet<FSemiLinearExp> FClass.collectSemiLinearExps() 
		[new HashSet<FSemiLinearExp>()] with add root FClass;
	FSemiLinearExp contributes this
		to FClass.collectSemiLinearExps()
		for myFClass();
}


aspect ReinitStates {
    
    public class FClass {
        /**
         * Transformation for marking up variables that have reinit() applied on them as states
         * (by setting stateSelect=always).
         */
        public class MakeReinitedVarsStates extends Transformation {
            public void perform() {
                for (FAbstractEquation eqn : getFAbstractEquations())
                    eqn.makeReinitedVarsStates();
            }
        }
    }
    
    /**
     * Mark all variables reinited in this equation as states.
     */
    public void FAbstractEquation.makeReinitedVarsStates() {}
    
    public void FIfWhenElseEquation.makeReinitedVarsStates() {
        for (FAbstractEquation e : getFAbstractEquations())
            e.makeReinitedVarsStates();
    }
    
    public void FIfWhenEquation.makeReinitedVarsStates() {
        super.makeReinitedVarsStates();
        if (hasElse())
            getElse().makeReinitedVarsStates();
    }
    
    public void FFunctionCallEquation.makeReinitedVarsStates() {
        getCall().makeReinitedVarsStates();
    }
    
    /**
     * It this is a reinit(), mark reinited variable as state.
     */
    public void FAbstractFunctionCall.makeReinitedVarsStates() {}

    /**
     * Mark reinited variable as state.
     */
    public void FReinit.makeReinitedVarsStates() {
        getVar().markReferencedVarAsState();
    }
    
    /**
     * Mark referenced variable as state.
     * 
     * Only valid for variable accesses, default implementation throws exception.
     */
    public void FExp.markReferencedVarAsState() {
        throw new UnsupportedOperationException();
    }
    
    /**
     * Mark referenced variable as state.
     */
    public void FAccessExp.markReferencedVarAsState() {
        myFV().markAsState();
    }
    
    /**
     * Mark this variable as a state, by setting stateSelect=always.
     */
    public void FAbstractVariable.markAsState() {
        throw new UnsupportedOperationException();
    }
    
    public void FVariable.markAsState() {
        FAttribute newA = new FInternalAttribute(FAttribute.STATE_SELECT, new FEnumLitExp(FAttribute.STATE_SELECT_TYPE, "always"));
        FAttribute oldA = findAttributeLocal(FAttribute.STATE_SELECT);
        if (oldA != null) {
            oldA.replaceMe(newA);
            addFAttribute(oldA);
        } else {
            addFAttribute(newA);
        }
    }
    
}
