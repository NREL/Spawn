#!/usr/bin/env python 
# -*- coding: utf-8 -*-

# Copyright (C) 2015 Modelon AB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from pyfmi import load_fmu
from pymodelica import compile_fmu
from pyjmi import transfer_optimization_problem, get_files_path
import matplotlib.pyplot as plt
import numpy as N
import os.path

def run_demo(with_plots=True):
    """
    This example demonstrates the solution of optimal experimental design (OED) problems.

    The example is based on a fed-batch reactor with two states, one algebraic variable. The model has 4 parameters to
    be estimated based on discrete measurements of the two states. The design space consists of two piecewise constant
    inputs, which are to be designed in order to maximize the information content in the measurements according to the
    A-criterion. In order to evaluate the objective, the model is augmented with variables and equations for the
    sensitivities of all the nidek variables with respect to the unknown parameters using forward sensitivities, which
    allows the formulation of the Fisher information matrix. An initial guess of the solution is generated by simulating
    the system with constant input values.
    """
    # Define outputs, parameters, and time points for needed sensitivities, and the experiment variance matrix sigma
    outputs = ['y1', 'y2']
    parameters = ['theta1', 'theta2', 'theta3', 'theta4']
    time_points = [2., 4., 6., 8., 10., 12., 14., 16., 18., 20.]
    sigma = N.array([[10., 0.], [0., 10.]])

    # Define nominal input values used as initial guess
    u_1_nom = 0.1
    u_2_nom = 15

    # Simulate model with sensititivies to generate initial guess for optimization
    model = load_fmu(os.path.join(get_files_path(), "FMUs", "FedBatchReactor.fmu"))
    sim_opts = model.simulate_options()
    sim_opts['sensitivities'] = parameters
    sim_opts['CVode_options']['rtol'] = 1e-8
    sim_res = model.simulate(options=sim_opts, input=(('u1', 'u2'), lambda t: (u_1_nom, u_2_nom)), final_time=20.)

    # Compile optimization problem
    op = transfer_optimization_problem('FedBatchReactor_OED', file_path)

    # Transform the optimization problem into an OED problem
    op.setup_oed(outputs, parameters, sigma, time_points, "T")

    # Set solver options
    opts = op.optimize_options()
    opts['init_traj'] = sim_res # Initial guess
    opts['nominal_traj'] = sim_res
    opts['blocking_factors'] = 10 * [3] # Piecewise constant inputs
    opts['n_e'] = 30 # Number of collocation elements
    opts['IPOPT_options']['linear_solver'] = "ma27"
    opts['verbosity'] = 1

    # Solve
    opt_res = op.optimize(options=opts)

    # Simulate optimal inputs to verify optimization discretization
    model.reset()
    sim_opts = model.simulate_options()
    sim_opts['sensitivities'] = parameters
    sim_opts['CVode_options']['rtol'] = 1e-8
    res = model.simulate(options=sim_opts, input=opt_res.get_opt_input(), final_time=20.)

    # Extract solution
    time = res['time']
    u1 = res['u1']
    u2 = res['u2']
    y1 = res['y1']
    y2 = res['y2']
    opt_time = opt_res['time']
    opt_u1 = opt_res['u1']
    opt_u2 = opt_res['u2']
    opt_y1 = opt_res['y1']
    opt_y2 = opt_res['y2']

    # Verify solution for testing purposes
    try:
        import casadi
    except:
        pass
    else:
        cost = float(opt_res.solver.solver_object.output(casadi.NLP_SOLVER_F))
        N.testing.assert_allclose(cost, -1.311920e+07, rtol=1e-3)

    # Plot solution
    if with_plots:
        plt.close(1)
        plt.figure(1)
        lw = 1.5
        ls = '-'
        plt.plot(time, y1, ls=ls, c='b', lw=lw)
        plt.plot(time, y2, ls=ls, c='g', lw=lw)
        plt.plot(time, u1, ls=ls, c='r', lw=lw)
        plt.plot(time, u2, ls=ls, c='c', lw=lw)
        ls = '--'
        plt.plot(opt_time, opt_y1, ls=ls, c='b', lw=lw)
        plt.plot(opt_time, opt_y2, ls=ls, c='g', lw=lw)
        plt.legend(['y1 sim', 'y2 sim', 'u1 sim', 'u2 sim',
                    'y1 opt', 'y2 opt'])
        plt.show()
