#include "fmi_paths.hpp"
#include "config.hpp"
#include "filesystem.hpp"
#include <iostream>

#if __has_include(<unistd.h>)
#include <unistd.h>
#include <dlfcn.h>
#endif

#if __has_include(<windows.h>)
#include <windows.h>
#endif

#if __has_include(<linux/limits.h>)
#include <linux/limits.h>
#endif

#if __has_include(<limits.h>)
#include <limits.h>
#endif

namespace spawn {

std::string version_string() {
  return "${CMAKE_PROJECT_VERSION_MAJOR}.${CMAKE_PROJECT_VERSION_MINOR}.${CMAKE_PROJECT_VERSION_PATCH}-${CMAKE_PROJECT_VERSION_BUILD}";
}

std::string fmi_platform() {
  return "${FMI_PLATFORM}";
}

spawn_fs::path exe() {
  auto get_path = [](){
    #if _WIN32
      TCHAR szPath[MAX_PATH];
      GetModuleFileName(nullptr, szPath, MAX_PATH);
      return spawn_fs::path(szPath);
    #else
      // if /proc/self/exe exists, this should be our best option
      char buf[PATH_MAX + 1];
      if (const auto result = readlink("/proc/self/exe", buf, sizeof(buf) - 1); result != -1) {
        return spawn_fs::path(std::begin(buf), std::next(buf, result));
      }

      // otherwise we'll dlopen ourselves and see where "main" exists
      Dl_info info;
      dladdr("main", &info);
      return spawn_fs::path(info.dli_fname);
    #endif
  };

  // canonical also makes the path absolute
  static const auto path = spawn_fs::canonical(get_path());
  return path;
}

spawn_fs::path exe_dir() {
  static const auto path = exe().parent_path();
  return path;
}

spawn_fs::path mbl_home_dir() {
  if (is_installed()) {
    return exe_dir() / "../etc/modelica-buildings/Buildings";
  } else {
    return project_source_dir() / "submodules/modelica-buildings/Buildings";
  }
}

bool is_installed() {
  return spawn::exe_dir().stem() == "bin";
}

spawn_fs::path idd_install_path() {
  constexpr auto & iddFileName = "Energy+.idd";
  // Configuration in install tree
  auto iddInputPath = spawn::exe_dir() / "../etc" / iddFileName;

  // Configuration in a developer tree
  if (! spawn_fs::exists(iddInputPath)) {
    iddInputPath = spawn::exe_dir() / iddFileName;
  }

  return iddInputPath;
}

spawn_fs::path epfmi_install_path() {
  const auto candidate = spawn::exe_dir() / ("../lib/" + spawn::epfmi_filename());
  if (spawn_fs::exists(candidate)) {
    return candidate;
  } else {
    return spawn::exe_dir() / spawn::epfmi_filename();
  }
}

spawn_fs::path msl_path() {
  spawn_fs::path p;
  if (is_installed()) {
    p = spawn::exe_dir() / "../etc/MSL/${MSL_VER}";
  } else {
    p = "${MSL_ROOT_DIR}/${MSL_VER}";
  }

  return p;
}

spawn_fs::path project_source_dir() {
  return "${PROJECT_SOURCE_DIR}";
}

spawn_fs::path project_binary_dir() {
  return "${PROJECT_BINARY_DIR}";
}

spawn_fs::path idd_path() {
  constexpr auto & iddfilename = "Energy+.idd";
  auto iddInputPath = exe_dir() / "../../resources" / iddfilename;

  if (! spawn_fs::exists(iddInputPath)) {
    iddInputPath = exe_dir() / iddfilename;
  }

  return iddInputPath;
}

std::string gfortranlib_name() {
  return "${GFORTRANLIB_NAME}";
}

spawn_fs::path gfortranlib_embedded_path() {
  return "${GFORTRANLIB_EMBEDDED_PATH}";
}

} // namespace spawn
